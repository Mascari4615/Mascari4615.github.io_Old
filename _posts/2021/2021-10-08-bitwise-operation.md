---
title: "비트 연산자, 시프트 연산자"
date: 2021-10-08. 19:35:00
last_modified_at: 2021-10-10
categories: Programming Programming-Normal
---

## 🗿 공통

---

- 정수형 데이터의 연산만 가능
  - 실수형 데이터는 불가능

## 🗿 비트 연산자 (Bitwise Operator)

---

- `&`
  - AND, 비트 AND 연산자
  - 양쪽 피연산자의 각 비트를 비교하여 양쪽 모두 1이면 1, 아니라면 0으로 설정.
  - 예시
        -

        ```c
            int x = 3;          // 3, ...0011
            int y = 5;          // 5, ...0101
            int z = x & y;
            printf("%d", z);    // 1, ...0001
        ```

- `^`
  - XOR, 포괄적 비트 XOR 연산자, (eXclusive OR)
  - 양쪽 피연산자의 각 비트를 비교하여 서로 다르면 1, 아니라면 0으로 설정.
  - 예시
        -

        ```c
            int x = 3;          // 3, ...0011
            int y = 5;          // 5, ...0101
            int z = x ^ y;
            printf("%d", z);    // 6, ...0110
        ```

- `|`
  - OR, 배타적 비트 OR 연산자
  - 양쪽 피연산자의 각 비트를 비교하여 한 쪽이라도 1이면 1, 아니라면 0으로 설정.
  - 예시
        -

        ```c
            int x = 3;          // 3, ...0011
            int y = 5;          // 5, ...0101
            int z = x | y;
            printf("%d", z);    // 7, ...0111
        ```
  - `Shift + Enter 위에 있는 키 ( ₩ )` 로 입력할 수 있음.

- `~`
  - NOT, 비트 보수(또는 비트 NOT) 연산자
  - 피연산자의 비트 보수를 만듦 (0에서 1, 1에서 0으로 수를 뒤집음)
  - 예시
        -

        ```c
            int x = 15;         // 15, ...0000'0000'0000'1111
            printf("%d", ~x);   //-16, ...1111'1111'1111'0000
        ```
  - 여담으로, `~` 는 단항 산술 연산자로 분류됨. (MSDC 기준)

## 🗿 비트 시프트 연산자

---

- 주의 할 점
  - 비트 시프트 연산자로 수행된 변환은 오버플로, 언더플로 조건을 지원하지 않음.
    - 때문에 연산 결과가 첫 번째 피연산자 형식으로 표현할 수 없는 경우,
    - 오류가 발생하지 않으며, 정보가 **손실**될 수 있음.

- `<<`
  - 첫 번째 피연산자를 두 번째 피연산자 만큼 왼쪽으로 이동.
  - 계산에 오버플로가 없는 경우, 첫 번째 피연산자에 2<sup>두 번째 피연산자</sup> 를 곱한 값과 같음.
  - 시프트 이후 비워진 비트는 0 으로 설정됨.
  - 예시
        -

        ```c
            int x = 15;         //  15, ...0000'0000'0000'1111
            int y = 4;
            int z = x << y;
            printf("%d", z);    // 240, ...0000'0000'1111'0000
                    //  15 * 2^4 = 240
        ```  

- `>>`
  - 첫 번째 피연산자를 두 번째 피연산자 만큼 오른쪽으로 이동.
  - 첫 번째 피연산자가 부호가 없거나, 음수가 아닌 경우, 2<sup>두 번째 피연산자</sup> 로 나눈 값과 같음.
  - 시프트 이후 비워진 비트는 첫 번째 피연산자의 형식에 따라 채워짐.
    - 부호 없는 `unsigned` 형식이면, 0으로 채워짐 (최상위 비트 설정 해제)
    - 부호 있는 형식이라면 부호 비트가 복사되여 채워짐. 양수 0, 음수 1 (최상위 비트 설정된 채 유지)
  - 예시
        -

        ```c
            int x = 240;        // 240, ...0000'0000'1111'0000
            int y = 4;
            int z = x >> y;
            printf("%d", z);    //  15, ...0000'0000'0000'1111
                    // 240 / 2^4 =  15
        ```  
  - 음수 값을 오른쪽으로 이동하면 원래 값의 반을 정수로 내림한 값이 생성됨.
    - -253 (11111111 00000011) 을 오른쪽으로 1비트 이동하면,
    - -127 (11111111 10000001) 이 생성됨.
    - 253 (00000000 11111101) 을 오른쪽으로 1비트 이동하면,
    - 126 (00000000 01111110) 이 생성됨.

## 🗿 할당 연산자

---

- 다른 연산자들과 마찬가지로 할당 연산자를 통해 값 변형과 할당을 동시에 할 수 있음.
  - `&=`
  - `^=`
  - `|=`
  - `~` 는 단항 산술 연산자라 할당 연산자가 존재하지 않음.
  - `<<=`
  - `>>=`

## 🗿 참고

---

- [MSDC](https://docs.microsoft.com/ko-kr/cpp/c-language/c-bitwise-operators?view=msvc-160)
- [Wikipedia - 비트 연산자](https://ko.wikipedia.org/wiki/%EB%B9%84%ED%8A%B8_%EC%97%B0%EC%82%B0)
- [Wikipedia - 산술 시프트](https://ko.wikipedia.org/wiki/%EC%82%B0%EC%88%A0_%EC%8B%9C%ED%94%84%ED%8A%B8)
- [Wikipedia - 논리 시프트](https://ko.wikipedia.org/wiki/%EB%85%BC%EB%A6%AC_%EC%8B%9C%ED%94%84%ED%8A%B8)

비트 마스크

& = ?

웹에서 계산기 만들기
