---
title: "⛏️ OS, 운영 체제 과목"
date: 2023-03-09. 14:53
last_modified_at: 2023-03-27. 11:32
categories: ⛏️Memo
---

책 안샀다  

---

- 시스템SW
  - 응용SW 작성/운용에 도움을 줄 수 있는, 사용자에게 편리성 제공, 시스템(컴퓨터)에 종속적인 경우가 많음(하드웨어나 다른 시스템 소프트웨어와 접속)(윈도우즈의 경우 창 단위 그래픽), 편집기/IDE, 어셈블리, 컴파일러, 운영체제 등  
- 응용SW
  - 사용자 개인(회사) 각각의 문제 해결을 위해  

- SW vs Program  
  - SW는 좀 더 총체적인  
  - Program은 좀 더 구체적인  

- 운영체제 Operating System  
  - 컴터를 운영하기 위한 수법과 절차를 모은 SW 체계  
  - 컴퓨터를 조정 운전하는 SW  

- 필요성  
  - 컴퓨터의 기본적인 처리 과정 고찰  
    - IPO Input-Process-Output  
    - 만약 마우스,키보드,모니터,프린터 등 기본적인 입출력 방법을 운영체제가 제공하지 않는다면
    - 키마 VS 콘솔  

- 주요 목적 기능
  - 편리성 추구
    - 사용자와 하드웨어 사이의 중계/기교 역할 담당
      - #인터페이스 역할
    - 사용자들이 컴퓨터를 편리하게 사용할 수 있도록 도움을 줌 (사용자 화면)
  - 효율성 추구
    - 컴퓨터에 설치된 자원들을 효율적으로 사용할 수 있도록 관리하는 자원 관리 역할  
      - #작업관리자 열어보면 수백개의 프로그램 프로세스가 실행 중
      - #CPU와 메모리를 어떻게 관리 분배
    - 값비싼 컴퓨터의 처리량을 향상시킴으로써 투자 효율 증대 (시스템측면)
  - 보안성 추구
    - 컴퓨터의 내부 자원HW와 사용자 정보DATA를 보호하는 역할 담당  
    - 컴퓨터와 사용자를 보호함으로써 지속적 운용 유지(사용자 & 컴퓨터 동시 만족)  

- 실체 및 활동
  - 하나의 거대한 프로그램
    - 사용자에게 서비스(프로그램 적재-실행(입력/계산/출력)-프로그램 제거)를 제공하기 위한 목적으로 메모리에 상주
    - 부트 과정을 거쳐 메모리에 설치됨  
  - 운영체제 접촉
    - 사용자들은 시스템 콜 System Call 이라 부르는 서비스 요청 접속 창구를 통해 서비스를 요청하고 결과를 되돌려 받음 (Operating System Interface)
    - 시스템 콜은  함수 (라이브러리) 형태로 제공되고, 사용자는 프로그램에서 호출하여 사용  
    - #printf, mkdir -> 프로그램이 모니터에 띄우는 게/디렉토리를 만드는 게 아니라, 이를 운영체제에 요청/부탁하고 = 시스템 콜 System Call, 운영체제가 모니터에 띄움/디렉토리를 만듬 -> 다시 호출된 곳으로 복귀  
    - #이 외에도 눈에 띄지 않는 운영체제 처리 들이 많음  
    - #atoi는 그냥 함수, 근데 printf은 운영체제로, 생긴 것 똑같은 데 처리 과정은 다를 수 있다
    - #Win32API - C, MFC - CPP, 시스템 프로그래머

- (시스템) 명령어
- #에 대한 이해
- #명령어는 결국 프로그램이다 = 운영체제에게 부탁하는 프로그램이다
  - 자주 사용되는 시스템콜을 매번 프로그램을 작성하여 서비스를 받아야 한다면 불편
    - 예) 디렉토리 생성삭제, 파일 생성삭제
  - 위와 같이 자주 사용되는 시스템 콜을 위해 미리 작성되어 있는 프로그램(#실행파일)을 시스템 명령어라 함
  - 유닉스/리눅스의 mkdir, rmdir, rm, vi  
  - 윈도우 도스창의 del, ren, mkdir, rmdir  

- 단일 프로그래밍 일괄처리 시스템, Single-stream(줄기가 하나) Batch(바구니, 뭉탱이 한 번에) Processing Systems
  - 오직 하나의 프로그램만을 적재하여 실행  
    - #공장처럼 하나 처리 후 다름
    - #HDD가 없었기에 펀치카드 다발을 통해 프로그램 자체를 올림  
    - #펀치카드 한 장 = 한 문장
  - 처리 중인 프로그램이 입출력 서비스를 요청했다면?  
    - #다른 일을 처리하지 못하고 계속해서 대기해야 함 => CPU 효율, Utilization 이용률, Through-put 단위 시간 당 처리량  

펀치카드 다발 (프로그램)  
|  
카드 리더기  
|  
Main Memory  
{  
    User Program  
    --  
    Operating System  
}  

- 다중 프로그래밍 일괄처리 시스템 Multiprogramming Batch Processing Systems
  - 메모리를 조각하여, 여러 개의 프로그램을 적재하여 실행  
    - #멀티 스트림, 근데 대신 멀티 프로그래밍이라는 용어를 쓴다
  - 처리 중이던 하나의 프로그램이 입출력 서비스를 요청했다면?  
    - #기본적으로는 처리 끝나거나, 입출력을 시작할 때까지 하나의 프로그램 처리
  - 자기 프로그램이 언제 끝날지 예측 불가
    - 다른 프로그램이 더 느리다면 그만큼 더 느리게  

펀치카드 다발 (프로그램)  
| | |  
카드 리더기  
| | |  
Main Memory  
{  
    User Program 2  
    User Program 1  
    User Program 0  
    --  
    Operating System  
}  

---

- 시분할 시스템 Time-Sharing Systems
  - 여러 개의 프로그램을 적재하여 실행하되
    - 짧은 시간 동안의 주기로 모든 프로그램을 골고루 조금씩 처리
    - 한 번에 주어지는 최대 처리 시간을 타임 퀀텀 Time Quantom 혹은 타임 슬라이스 Time Slice
  - 다중 사용자들의 대화적 처리 Interactive Processing 환경에 적합

- 병렬 처리 Parallel Processing System
  - 다중처리기 시스템 Multi Processor System
    - 처리기 CPU 를 여러 개 장착한 시스템
    - #왜 CPU가 아니라 Processor
      - #Processor - CPU FPU GPU 일반화
      - #여기선 CPU를 의미
    - 처리기 수 만큼의 프로그램들이 병렬로 처리될 수 있음
    - 처리기 일부가 고장나더라도 나머지 처리기들로 기능유지 가능
      - 결함 허용 컴퓨터 Fault Tolerant Computer
      - 성능 Throughput 과 신뢰성 Reliability 향상
        - #성능 - CPU를 여러 개 장착하는 주된 이유
  - 병렬 처리 Parallel Processing 와 병행 처리 Concurrent Processing
    - 병렬 처리는 어떤 시각을 기준에서 여러 개의 프로그램을 처리
    - 병행 처리는 어떤 시각을 기준에서 오직 한 개의 프로그램을 처리하나, 번갈아 처리함으로써 전체적(거시적)으로 여러 개의 프로그램을 처리하는 효과를 얻음
  - 넓은 의미에서 분산 Distributed 처리 시스템의 일종
    - 일반적으로 여러 독립된 시스템을 네트워크로 연결
    - 시스템 하나에 처리하는 놈을 여러 개 두는 : 간결화 시스템 : 버스로 연결, Tightly-Coupled
    - 시스템을 독립시켜놓고 네트워크로 연결하여 분단 처리 : 약결합 시스템 Loosely Coupled

- 병렬 처리  
  - 대칭형과 비대칭형 다중 처리기 시스템
    - 대칭형 다중 처리기 시스템 SMP Symmetric Multi-Processor System
      - 처리기들의 역할 범위가 동등, 즉 마스터-슬레이브 개념 없음
      - 어느 처리기나 사용자 영역과 시스템 영역 실행 가능
        - 운영체제에 부담
        - 동시에 시스템 영역을 사용하면 경쟁 상태 발생 가능
      - 처리기 하나가 고장나도 작동
    - 비대칭형 다중  처리기 시스템 ANP Asymmetric
      - 마스터 처리기와 슬레이브 처리기 지정
      - 시스템 영역은 마스터 처리기만 실행 가능
      - 마스터 처리기가 고장나면 시스템 전체 스톱  
      - 운영체제 부담, 구현 난이도 감소
      - 마스터 고장나면 대책이 없다

- 처리기들 간 버스 연결 방식 (강결합 시스템)
  - 단일 공유 버스 Single Shared Bus
    - 시스템 전체적으로 하나의 버스를 두고 처리기들이 경쟁하여 사용  
      - 배타적으로, 하나가 버스를 쓰고 있다면 (데이터를 주고 받고 있다면), 다른 하나가 버스를 사용할 수 없다 (데이터가 깨지니까)  
    - 처리기를 너무 많이 탑재하면 성능이 오히려 저하
      - CPU를 여러 개 꽂아도, 대기 시간이 존재하기에 성능 향상이 점점 줄어든다
    - 멀티 코어 처리기는 처리기들을 하나의 칩으로 통합하여 버스 경쟁, 캐시 정책, 전력 소모 등을 최적화
  - 다중 버스 Multiple Bus
    - 버스를 여러 개 두고 버스 경쟁률을 완화
    - 메모리를 버스 개수 만큼 나눈다
    - 은행 창구처럼, 톨 게이트처럼, 하나의 버스가 사용중이면 다른 버스로 메모리에 접근
  - 크로스 바 스위치 버스 Crossbar Switch Bus
    - 메모리를 여러 개의 모듈 (뱅크)로 분리
    - 모든 처리기와 메모리 모듈 사이에 독립적인 버스 경로 가능
    - 버스 경쟁으로 인한 성능 저하 최소화
    - 같은 버스 수로 다중 버스의 효과를 내면서
      - 같은 메모리 뱅크를 사용하지 않는 한
      - 대기 시간이 있기는 있음
  - 계층적 버스 Hierarchical Bus
    - 처리기별로 로 접근컬 메모리, 로컬 디바이스, 로컬 버스를 두고, 대부분로컬 버스로 처리
    - 시스템 메모리 접근이 필요한 경우에만 브릿지 컴포넌트를 통해 시스템버스를 사용
    - 글로벌 메모리에 있는 변수 접근 시 대기 시간
    - 소프트웨어 적으로도 (컴파일러) 여러 기능 필요
      - 시스템 메모리로의 주소 바인딩
  - 다중 포트 메모리 Multi Port Memory
    - 메모리에 접근 포트를 여러 개 두고 각각 독립적으로 경로 가능, 접근 가능
    - 각 처리기 별로로 독립된 버스를 분리된 메모리 포트에 연결하여 각각의 병렬 접근을 허용
    - 보통 듀얼 포트
    - 비디오 RAM (VRAM)이 대표적 사례
      - CPU 각 픽셀의 색 설정
      - GPU 각 픽셀을 모니터에 출력
      - 메모리 버스를 가지고 경쟁, 하나가 느리면 병목 현상, 끊어보인다던지  
      - 그래서 메모리도 크고, 다중 포트  

- #메모리는 여러 종류
- #메인 메모리, 비디오 메모리 등

- 분산 처리 (약결합) 시스템
  - 여러 개의 독립된 시스템을 네트워크로 연결
  - 주어진 일을 분담하여 병렬 처리
  - 다중 처리기 시스템도 넓은 의미에서 분산처리 시스템 -> 강결합 시스ㅡ템
  - 보통은 약결합 시스템 혹은 클러스터라고 함
- 분산 처리 시스템의 목적
  - 처리량 향상, 자원 활용도 향상, 시스템 신뢰도 향상, 점진적 시스템 확장
- 분산 처리 시스템의 제공 기능
  - 위치 투명성(분리 된 것이 아니라 우리, 하나로 보이게), 고장 투명성(고장나도 모르고), 접근 투명성(차이가 있어서는 안된다), 중복 및 이동 투명성(중복이어도, 시스템 A에서 B로 옮겨지더라도 사용자가 모르고 쓸 수 있게)

- 분산 처리 시스템의 연결 방식
  - 하이퍼큐브 Hyper Cube
    - 하이퍼 큐브 연결방식이 대표적
    - 8 노드 (시스템)인 경우 각 노드는 3개의 인접 노드를 가짐
    - 16노드인 경우 각 노드는 4개의 인접 노드를 가짐
  - 완전 연결 Fully Connected
    - 초기 설치 비용이 큼
    - 사이트 확장 비용이 큼
    - 사이트 간 통신 속도가 빠름
    - 선로 고장에 따른 신뢰도가 높음
  - 성형 Star
    - 초기 설치 비용 적음
    - 가운데 중계 시스템의 부하 과대
    - 중계 시스템의 고장에 따른 신뢰도 저하
    - 사이트 추가 비용이 적음
  - 링형 Ring
    - 완전 연결과 성형의 절충
    - 초기 설치와 사이트 확장 비용이 비교적 저렴
    - 두 개 이상의 사이트 고장은 네트워크 양분

- NOS

---

- 실시간 시스템 RealTime Systems
  - 프로그램의 처리 마감 시한을 보장하느 시스템 (실시간 처리 환경)
    - 어떤 사건 Event을 기다리는 프로그램에게, 사건 발생 시각부터 처리 완료 시까지의 최대 소요시간 한계를 보장
      - -> 사건이 발생했는데도 불구하고 해당 프로그램의 실행이 오래도록 지연된다면?
  - 경성 실시간 시스템 Hard Real-Time Systems
    - 프로그램의 처리 마감 시한을 원래의 개념대로 엄격하게 보장
  - 연성 실시간 시스템 Soft Real-Time Systems
    - 프로그램의 처리 마감 시한을 원래의 개념대로 엄격하게 보장하지는 못하지만, 해당 프로그램의 처리 지연을 최소화 시킬 수 있음.
    - 범용 운영체제인 유닉스, 리눅스, 윈도우 등에서 실시간성 프로그램을 분류하여 관리

---

- 컴퓨터 시스템 주요 구성 요소  
  - 중앙처리장치 CPU Central Processing Unit  
  - 주기억장치 Main Memory  
    - 왜 '주' 기억장치냐, CPU가 직접 참조  
  - 주변 장치 Peripheral Device  

- processor (프로세서)
  - 처리기, 일반적으로 중앙처리장치 (CPU) = 명령어를 해석하는 컴퓨터의 한 부분  
  - 그래픽처리장치 (GPU) 도 컴퓨터의 일부이지만 단지 '프로세서' 라는 용어만 사용하였을 때 그래픽 처리 장치를 뜻하는 경우는 아직 많지 않음  
  - 
- MainBoard, MotherBoard, SystemBoard
  - 다 똑같은 용어, 우리나라는 보통 메인보드라 칭하고, 해외에서는 마더보드라 칭하는 경우가 많음  

- 시스템 버스 System Bus  
  - 어드레스 버스 Address Bus  
    - 메모리나 입출력 장치에 접근할 때 접근 장소를 식별하기 위한 주소를 전달  
    - 메모리 크기에 따라 8 16 24 32 64 비트(라인) 등의 크기를 가짐  
  - 데이터 버스 Data Bus (R/W)  
    - 메모리나 입출력 장치에서 데이터를 보내거나 읽어올 데이터를 전달  
    - 데이터 전송 대역폭에 따라 8 16 32 64 비트(라인)등의 크기를 가짐  
  - 제어 버스 Control Bus (R/W하는 명령/신호 같은)  
    - 메모리나 입출력 장치 등에 읽기/쓰기 등의 기능을 제어하기 위한 신호 전달  
    - 신호의 종류에 1/2/3 비트 (라인) 등의 크기를 가짐  

- RAM Random Access Memory  
  - 임의의 주소에 접근  

- I.E. 8라인 = 2의 8승 = 256B  
- I.E. 16라인 = 2의 16승 = 64KB  
- I.E. 32라인 = 2의 32승 = 4GB  
- 2의 10승 = 1024 = 1K  

- 주기억장치 Main Memory
  - 비트 Bit 와 바이트 Byte
    - 비트 0/1을 기록하는 메모리의 최소 구성 소자
    - 바이트 : 8비트로 구성되면 256가지의 서로 다른 정보 저장 가능
  - 바이트 별 주소 지정
    - 대부분의 컴퓨터는바이트 단위로 주소를 부여
  - 바이트 단위 저장
    - 읽거나 쓰기는 반드시 바이트 단위로 이루어짐
  - 1/2/4/8 바이트 동시 접근 (읽기/쓰기)
    - 기계 명령어 Machine Instruction 에 따라 동시 접근하는 바이트 수가 다름  
  - 메모리 얼라이먼트 Memory Alignment
    - 2 4 8 등의 바이트 동시 접근 시 목표시작 주소를,  
    - 2 4 8의 배수가 되도록 요구하는 기계 CPU 가 있음  
    - #1 바이트는 어디서든 되는  

- 기계 명령어 Machine Instruction
  - CPU가 처리하는 명령어 단위
    - 고급 언어로부터 번역되어 실행 시 메모리에 적재
    - CPU에 의해 인출되어 처리됨
  - 연산코드 Operation Code 와 피연산자 Operand
    - 연산 코드는 피연산자에 적영할 덧셈, 뺄셈 등의 연산을 의미하는 코드
    - 피연산자는 연산에 사용될 값을 의미
    - 피연산자로 주기억장치 주소, 상수 ,CPU 레지스터 번호 등이 가능
    - = 위와 같이 다양한 형태의 피연산자를 어드레싱 모드 ADdressing mode라 함
    - 피연산자 부분의 크기는 주기억장치의 크기에 영향을 받음
    - #전형적인 기계 명령어 포맷 연산코드 4비트+피연산자 12비트  
    - #피연산자 최대 크기에 맞춰서  

---

### (CPU) 명령 사이클 (기계 사이클)

[참고](https://gamedevlog.tistory.com/71)  

Instruction : 명령, (사전 = 지침)  

- Fetch (=bring) 인출
  - CPU가 명령을 수행하기 위해 그 명령어를 레지스터에서 꺼내 오는 것
  - 위 말고도 그냥 일반적으로 가져온다는 뜻으로 많이 쓰이기도 하는 듯

- (CPU) 명령 사이클 Instruction Cycle (기계 사이클 Machine Cycle)  
  - CPU의 일과
    - Memory(#주기억장치)로부터 끊임없이 기계 명령어를 주소 번호대로 (차례로) 인출, 해당 명령어가 요구하는 동작을 수행/처리  
    - 점프를 의미하는 기계 명령어를 만나면 명령어 인출 위치를 변경
  - 인출 사이클 Fetch Cycle
    - 이번 차례 주소(PC가 가르키는 곳)의 주 기억장치에서 명령어를 읽어 옴
    - 인출이 완료되면, PC는 다음 차례의 명ㄴ령어 주소로 업데이트됨
  - 해독 사이클 Decoding Cycle
    - 연산 코드를 분석하여 어떤 연산인지를 식별함
  - 피연산자 사이클 Operand Cycle
    - 피연산자 인출이 필요한 경우 지정된 곳에서 피연산자를 읽어옴
  - 실행 사이클 Execution Cycle
    - 누산기와 피연산자 사이에 연산을 적용하여 명령어를 실행
  - #더 세부적으로 나눌 수도 있고, 각 단계를 더 나눌 수도 있음 (마이너 사이클 or Micro Operation != 메이저 사이클)
  - #톱니바퀴형 파이? 클럭 (CPU 파형)?

- 레지스터 Register
  - 레지스터 Register란?
    - 값을 저장하는 곳 중 하나
    - 메모리와 달리 불규칙적, 소량
    - 단순한 값의 저장 기능 외에, 저장 값에 따라 하드웨어 등의 상태에 영향을 미침
    - 레지스터는 CPU 내 번호, 주기억장치 주소의 일부 영역, 입출력 포트 번호 등에 의해 젖ㅂ근됨
  - 레지스터의 유형
    - CPU 레지스터
      - CPU 내에서 위치하여 CPU 제어, 연산 (누산기) = A Register, 값의 임시 저장 용도 = S Register 로 사용
      - #A, PC, MBR, MPN | S, T
    - 특수 기능 레지스터 SFR Special Function Register
      - 컴퓨터 전반에 걸친 상태를 설정하거나 현재 상태 표시
    - 입출력 레지스터
      - 입출력 장치와 연결되어 입력이나 출력할 때 데이터 전달 통로 역할

- 주소 지정 모드 Addressing Mode
  - 주소 즉시 Address Immediate 주소 지정 모드
    - 주소 모드
      - 피연산자에 나타난 값을 주소로 해석함 (직접 간접, 절대 상대 주소 해당)
    - 즉시 모드
      - 피연산자에 나타난 값은 상수로 해석함
  - 직접 간접 Direct Indirect 주소 지정 모드
    - 직접 주소
      - 기계 명령어의 피연산자 부분이 주기억장치 접근 주소로 사용되는 경우
      - #주소 -> 값 가져옴
    - 간접 주소
      - 피연산자 부분이 가르키는 곳에 저장된 기억장치 같이 2차(최종) 주소로 사용되는 경우
      - #주소 -> 주소 -> 값 가져옴 Like 포인터
  - 절대 상대 Absolute Relative 주소 지정 모드
    - 절대 주소
      - 피연산자에 나타난 주소가 그대로 주기억장치 접근 주소로 사용되는 경우
      - #주소 -> 값 가져옴
    - 상대 주소
      - 피연산자에 나타난 주소에 제 3의 기준 값을 더한 값이 주기억장치 접근 주소로 사용되는 경우
      - #주소 + 기준 값 -> 값 가져옴

- OP Coder 연산 코드, Operand 피연산자  
- I.E. Add_절대/상대_직접/간접, 상수  

---

[참고 0](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8_%ED%95%B8%EB%93%A4%EB%9F%AC)  
[참고 1](https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)  

- 인터럽트 Interrupt (가로채기, 처리 중간에 방해/중단되고 다른 일을 잠시 처리, 큰 틀에서 봤을 때 처리하는 일은 변함 없음)  
  - #CPU에서 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에게 알려 처리할 수 있도록 하는 것
  - CPU에 전달되는 사전 신호 Event Signal
  - 사건 신호에는 여러 가지가 있으며, 주로 각각의 전용 회선으로 전달됨 (Source I.E. 키보드 마우스 등)
    - Vectored Interrupt
  - 전용 회선이 없는 경우, 어떤 인터럽트가 발생했는지를 탐색해야 함
    - Interrupt Polling(Polling Interrupt)

- != [Polling (폴링)](https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))
  - 폴링은 하나의 장치 혹은 프로그램이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치 혹은 프로그램의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 소우신 등의 자료처리를 하는 방식
  - 인터럽트는 대상을 주기적으로 감시하여 상황이 발생하면 해당처리 루틴을 실행해 처리하는 폴링과는 달리, 상대가 CPU에게 일을 처리해 달라고 요청하는 수단

- ISR, Interrupt Service Routine Or Interrupt Handler

- 인터럽트 우선 순위 Interrupt PRiority
  - 여러 개의 인터럽트가 동시에 발생한 경우 대응 처리 순서를 결정함
  - 기 발생한 인터럽트에 대한 대응 처리 도중, 다른 인터럽트가 발생했을 때, 그 인터럽트를 보류 시킬 것인지 아니면 지금 즉시 처리할 것인지를 결정함
    - 새로 발생한 인터럽트의 우선 순위가 더 높으면 진행 중이던 대응 처리를 잠시 유보하고 새로운 인터럽트 처리를 먼저 처리한 후 재개함
- 인터럽트 사이클 Interrupt Cycle
  - CPU가 인터렙트 발생 여부를 체크(조사)하는 시기를 말함
  - 4단계의 명령/기계 사이클을 마치고 인터럽트 발생 여부를 조사함
    - 즉, 하나의 기계 명령어에 대한 처리를 마칠 때마다 조사함
    - 결국, 명령/기계 사이클은 인터럽트 사이클을 포함하여 총 5단계로 이루어져 있음

- 인터럽트 유형
  - 디바이스 인터럽트 Device Interrupt
    - 입출력 장치 등 CPU 외부 주변 기기에서 발생하는 인터럽트
      - 하드웨어 인터럽트 HW Interrupt 라고도 함
    - 오류 인터럽트 Error Interrupt
      - CPU가 기계 명령어를 처리하는 도중에 발생하는 인터럽트
      - 잘못된 기계 명령어를 만나거나 0으로 나누는 등의 연산 불가 상황에서 발생
        - 예상하지 않는 오류 발생이란 뜻에서 예외 Exception라고 함
    - 소프트웨어 인터럽트 SW Interrupt
      - 인터럽트를 발생시키는 기계 명령어, 즉 프로그램에 의해 발생된 인터럽트
      - 인터럽트 대응 처리를 테스트하거나, 시스템 콜을 위해 사용자 프로그램에서 운영체제로 진입하기 위해 사용
        - 프로그램의 흐름을 인위적으로 특별한 부분으로 빠져들게 하므로 트랩 Trap 이라고도 함

- 이중 모드 Dual Mode Operation  
  - CPU가 사용자 영역과 시스템 영역을 드나드는 것  

- CPU의 실행모드
  - 시스템 모드 System Mode
    - CPU가 운영체제 부분을 실행할 때 설정되는 모드
      - 특권 모드 Privileged Mode 또는 수퍼바이저 모드라고도 함
  - 사용자 모드
    - CPU가 사용자 프로그램을 실행할 때 설정되는 모드
      - 단순히 프로그램 모드라고도 함
- 특권 명령어 Privileged Instruction
  - 시스템 모드에서만 실행 가능한 기계 명령어
  - 사용자모드에서 실행될 경우 예외 발생
  - 입출력 명령어 등 시스템 보호 및 유지를 위해 필요
- 모드간 이동
  - 시스템 모드에서 시작(부팅과정)
  - 시스템 모드 -> 사용자 모드
    - 운영체제가 사용자 모드로 변경하고 사용자 프로그램으로 점프
  - 사용자 모드 -> 시스템 모드
    - 시간 초과 등의 인터럽트에 의해 운영체제 내 ISR 로 점프하면서 설정

- 입출력 장치 IO Device
  - 입력 Input
    - CPU, DMA 등 처리기가 주변 장치의 데이터 레지스터 Data Register로부터 데이터 값을 읽어 주기억장치로 복사하는 작업
    - 데이터 레지스터로부터 값을 읽을 때에는 상태 레지스터 Status Register의 데이터 준비 상태를 확인해야 함
      - 준비되지 않은 상태에서 읽을 경우 엉터리 값을 읽게 됨
  - 출력 Output
    - 입력과 반대로 주기억장치으 데이터 값을 읽어 주변장치의 데이터 레지스터로 복사하는 작업
    - 데이터 레지스터에 값을 쓰기할 때에는, 상태 레지스터에서 이전 데이터의 출력이 완료되었는지 확인해야 함
      - 이전 데이터의 출력 완료 전 또 다른 데이터를 쓰기하면 출력 데이터의 정확성이 보장되지 않음

- 입출력 장치 구조
  - 입출력 장치 제어기 IO Device COntroller 입출력장치인터페이스
    - 상태 레지스터 Status Register
      - 데이터가 입력되었는가 혹은 데이터 출력이 완료되었는 가 등 장치의 상태를 표시하는 곳
    - 명령 레지스터 Command Register
      - 입력 혹은 출력 하라는 등의 명령을 보내는/쓰는 곳
      - 입력 명령에 따라 입력 => 동기적 입력 (디스크 등)
      - 입력 명령없이 수시로 입력 => 비동기적 입력 (키보드 등)
      - 출력은 언제나 동기화
    - 데이터 레지스터 Data Register
      - 입력된 데이터나 출력될 데이터를 임시 보관하고 있는 곳
    - 입출력 장치 구동기 IO Device Driver
      - 장치 제어기 인터페이스를 이용하여 입출력을 처리하는 소프트웨어

- 입출력 장치의 식별
  - 메모리 대응 입출력 Memory Mapped IO
    - 입출력 장치의 레지스터들의 위치를 주기억장치의 주소영역 일부에 대응
    - 주기억장치 (변수, 주소)에서 읽고 쓰기하는 동일한 방법으로 입출력이 이루어짐
    - 즉, 메모리 접근 명령어와 동일한 기계 명령어 (load, save 등)를 사용하여 입출력을 진행함
      - 개발자 입장에서 편리하나, 메모리 공간의 일부는 사용할 수 없음

- 입력 예  
  - load r1, 10
    - 메모리 10번지에 대응된 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)
  - save r1, 1000  
    - 입력된 데이터를 메모리 1000번지에 저장
- 출력 예
  - load r1, 2000
    - 메모리 2000번지의 데이터를 CPU의 r1 레지스터로 적재
  - saver1, 20
    - 적재된 데이터를 메모리 20번지에 대응된 출력 레지스터에 기록 (출력)

- 격리된 입출력 Isolated IO
  - 주기억 장치의 주소 영여과 별개로 입출력 장치 주소 영역 (포트, Port)이 따로 있음
  - 즉, 메모리 10번지와 입출력 포트 10의 숫자는 동일하지만 지시하는 위치는 전혀 다름
  - 따라서, 메모리 접근 기계어 외에 입출력 포트 접근을 위한 전용 기계 명령어 (in, out 등)가 필요함
  - = 메모리 공간을 모두 사용할 수 있으나, 시스템 설계가 다소 복잡해짐

- 입력 예  
  - in r1, 10
    - 입력 포트 10번지의 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)
  - save r1, 1000
    - 입력된 데이터를 메모리 1000번지에 저장
- 출력 예
  - load r1, 2000
    - 메모리 2000번지의 데이터를 CPU의 r1레지스터로 적재
  - out r1, 20
    - 적재된 데이터를 메모리 20번지인 출력 레지스터에 적재 (출력)

- 컴퓨터 저장장치
  - 컴퓨터에 사용되는 저장장치는 가격, 성능, 용량에 따라 계층을 이루고 있다

CPU 레지스터 CPU Register  
캐시 Cache { S-RAM Static }  
주기억장치 Main Memory { D-RAM Dynamic Random Access Memory }  
전자디스크 Electronic Disk { SSD }  
자기디스크 Magnetic Disk { HDD }  
광디스크 Optical Disk { CD ROM, DVD }  
자기테이프 Magnetic Tape  

- 레지스터
  - CPU내에 존재하는 연산 및 임시 저장 용도의 저장 공간
- 캐시
  - CPU와 주기억장치 사이의 속도차 극복을 위한 소량, 고속, 고가 메모리
  - 프로그램의 지역성 특성에 의거 90% 이상의 적중
    - #500번지에 접근한다고 할 때, 또 다시 500번지에 접근할 가능성이 높음
    - #때문에 캐시에 적재하는 것이 비효율적이지 않다  
- 전자 디스크
  - 플래시 메모리 기술에 기반한 SSD Solid State D

- memory (메모리)
  - 레지스터(CPU) - 캐시메모리 - 주기억장치 - (캐시메모리) - 보조기억장치
  - 일반적으로 용량과 속도 반비례, 속도와 용량 대비 가격 비례

  - 레지스터 데이터 읽기 = 머릿속에 있는 기억 떠올리기
  - 주기억장치 데이터 읽기 = 책장에 꽂혀 있는 책에서 특정한 책을 찾아 내용을 읽는 행동
  - 보조기억장치 데이터 읽기 = 지구를 한 바퀴 돌아서 특정한 내용 찾아오기

  - [메소드 스텁](https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C_%EC%8A%A4%ED%85%81)  

- register (레지스터)
  - 프로세서에 위치한 고속 메모리
  - 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역
  - 컴퓨터 구조에 따라 크기와 종류가 다양

TODO : 책 사야 함 (문제 종종 내심..!)  

문제 4-2 명령어  
한 자리씩 오른쪽으로 밀린다, 가장 오른쪽에 있었던 것은 가장 왼쪽으로 간다.  

- 입출력 개관

- 입출력 과정
  - 응용 프로그램의 입출력 요구 => 운영체제 => 입출력 장치 (입출력 하드웨어) 인터페이스
  - 디스크, 키보드, 모니터, 인터넷 통신, 블루투스 통신, 시리얼 통신  

- 직접 데이터 입출력과 간접 데이터 입출력
  - 직접 입출력
    - 운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공없이 그대로 전달
    - #RAW Device
    - #Special File (!Regular File)
    - #Major Number, Minor Number
  - 간접 입출력 (대부분이)  
    - 운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공하여 전달  
    - #계층적 저장구조를 위해서  
    - #파일 시스템
    - #TCP/IP 프로토콜 네트워크 패킷(헤더) 같은 걸 붙이는  

- 문자 Character 입출력 장치와 블록 Block 입출력장치
  - 문자 입출력 장치
    - 바이트 단위의 가변적 크기의 입출력 (키보드, LAN 등)
  - 블록 입출력 장치
    - 디스크의 512바이트 단위 입출력과 같이 일정한 크기의 블록 단위 입출력  
    - #하드디스크는 한 바이트를 수정하려면 그 바이트가 포함된 한 섹터를 수정하고 전체를 덮어씌워야 함  
