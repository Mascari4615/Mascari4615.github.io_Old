---
title: "⛏️ OS, 운영 체제 과목"
date: 2023-03-09. 14:53
last_modified_at: 2023-05-01. 15:34
categories: ⛏️Memo
---

- 시스템SW
  - 응용SW 작성/운용에 도움을 줄 수 있는, 사용자에게 편리성 제공, 시스템(컴퓨터)에 종속적인 경우가 많음(하드웨어나 다른 시스템 소프트웨어와 접속)(윈도우즈의 경우 창 단위 그래픽), 편집기/IDE, 어셈블리, 컴파일러, 운영체제 등  
- 응용SW
  - 사용자 개인(회사) 각각의 문제 해결을 위해  

- SW vs Program  
  - SW는 좀 더 총체적인  
  - Program은 좀 더 구체적인  

- 운영체제 Operating System  
  - 컴터를 운영하기 위한 수법과 절차를 모은 SW 체계  
  - 컴퓨터를 조정 운전하는 SW  

- 필요성  
  - 컴퓨터의 기본적인 처리 과정 고찰  
    - IPO Input-Process-Output  
    - 만약 마우스,키보드,모니터,프린터 등 기본적인 입출력 방법을 운영체제가 제공하지 않는다면
    - 키마 VS 콘솔  

- 주요 목적 기능
  - 편리성 추구
    - 사용자와 하드웨어 사이의 중계/기교 역할 담당
      - #인터페이스 역할
    - 사용자들이 컴퓨터를 편리하게 사용할 수 있도록 도움을 줌 (사용자 화면)
  - 효율성 추구
    - 컴퓨터에 설치된 자원들을 효율적으로 사용할 수 있도록 관리하는 자원 관리 역할  
      - #작업관리자 열어보면 수백개의 프로그램 프로세스가 실행 중
      - #CPU와 메모리를 어떻게 관리 분배
    - 값비싼 컴퓨터의 처리량을 향상시킴으로써 투자 효율 증대 (시스템측면)
  - 보안성 추구
    - 컴퓨터의 내부 자원HW와 사용자 정보DATA를 보호하는 역할 담당  
    - 컴퓨터와 사용자를 보호함으로써 지속적 운용 유지(사용자 & 컴퓨터 동시 만족)  

- 실체 및 활동
  - 하나의 거대한 프로그램
    - 사용자에게 서비스(프로그램 적재-실행(입력/계산/출력)-프로그램 제거)를 제공하기 위한 목적으로 메모리에 상주
    - 부트 과정을 거쳐 메모리에 설치됨  
  - 운영체제 접촉
    - 사용자들은 시스템 콜 System Call 이라 부르는 서비스 요청 접속 창구를 통해 서비스를 요청하고 결과를 되돌려 받음 (Operating System Interface)
    - 시스템 콜은  함수 (라이브러리) 형태로 제공되고, 사용자는 프로그램에서 호출하여 사용  
    - #printf, mkdir -> 프로그램이 모니터에 띄우는 게/디렉토리를 만드는 게 아니라, 이를 운영체제에 요청/부탁하고 = 시스템 콜 System Call, 운영체제가 모니터에 띄움/디렉토리를 만듬 -> 다시 호출된 곳으로 복귀  
    - #이 외에도 눈에 띄지 않는 운영체제 처리 들이 많음  
    - #atoi는 그냥 함수, 근데 printf은 운영체제로, 생긴 것 똑같은 데 처리 과정은 다를 수 있다
    - #Win32API - C, MFC - CPP, 시스템 프로그래머

- (시스템) 명령어
- #에 대한 이해
- #명령어는 결국 프로그램이다 = 운영체제에게 부탁하는 프로그램이다
  - 자주 사용되는 시스템콜을 매번 프로그램을 작성하여 서비스를 받아야 한다면 불편
    - 예) 디렉토리 생성삭제, 파일 생성삭제
  - 위와 같이 자주 사용되는 시스템 콜을 위해 미리 작성되어 있는 프로그램(#실행파일)을 시스템 명령어라 함
  - 유닉스/리눅스의 mkdir, rmdir, rm, vi  
  - 윈도우 도스창의 del, ren, mkdir, rmdir  

- 단일 프로그래밍 일괄처리 시스템, Single-stream(줄기가 하나) Batch(바구니, 뭉탱이 한 번에) Processing Systems
  - 오직 하나의 프로그램만을 적재하여 실행  
    - #공장처럼 하나 처리 후 다름
    - #HDD가 없었기에 펀치카드 다발을 통해 프로그램 자체를 올림  
    - #펀치카드 한 장 = 한 문장
  - 처리 중인 프로그램이 입출력 서비스를 요청했다면?  
    - #다른 일을 처리하지 못하고 계속해서 대기해야 함 => CPU 효율, Utilization 이용률, Through-put 단위 시간 당 처리량  

펀치카드 다발 (프로그램)  
|  
카드 리더기  
|  
Main Memory  
{  
    User Program  
    --  
    Operating System  
}  

- 다중 프로그래밍 일괄처리 시스템 Multiprogramming Batch Processing Systems
  - 메모리를 조각하여, 여러 개의 프로그램을 적재하여 실행  
    - #멀티 스트림, 근데 대신 멀티 프로그래밍이라는 용어를 쓴다
  - 처리 중이던 하나의 프로그램이 입출력 서비스를 요청했다면?  
    - #기본적으로는 처리 끝나거나, 입출력을 시작할 때까지 하나의 프로그램 처리
  - 자기 프로그램이 언제 끝날지 예측 불가
    - 다른 프로그램이 더 느리다면 그만큼 더 느리게  

펀치카드 다발 (프로그램)  
| | |  
카드 리더기  
| | |  
Main Memory  
{  
    User Program 2  
    User Program 1  
    User Program 0  
    --  
    Operating System  
}  

---

- 시분할 시스템 Time-Sharing Systems
  - 여러 개의 프로그램을 적재하여 실행하되
    - 짧은 시간 동안의 주기로 모든 프로그램을 골고루 조금씩 처리
    - 한 번에 주어지는 최대 처리 시간을 타임 퀀텀 Time Quantom 혹은 타임 슬라이스 Time Slice
  - 다중 사용자들의 대화적 처리 Interactive Processing 환경에 적합

- 병렬 처리 Parallel Processing System
  - 다중처리기 시스템 Multi Processor System
    - 처리기 CPU 를 여러 개 장착한 시스템
    - #왜 CPU가 아니라 Processor
      - #Processor - CPU FPU GPU 일반화
      - #여기선 CPU를 의미
    - 처리기 수 만큼의 프로그램들이 병렬로 처리될 수 있음
    - 처리기 일부가 고장나더라도 나머지 처리기들로 기능유지 가능
      - 결함 허용 컴퓨터 Fault Tolerant Computer
      - 성능 Throughput 과 신뢰성 Reliability 향상
        - #성능 - CPU를 여러 개 장착하는 주된 이유
  - 병렬 처리 Parallel Processing 와 병행 처리 Concurrent Processing
    - 병렬 처리는 어떤 시각을 기준에서 여러 개의 프로그램을 처리
    - 병행 처리는 어떤 시각을 기준에서 오직 한 개의 프로그램을 처리하나, 번갈아 처리함으로써 전체적(거시적)으로 여러 개의 프로그램을 처리하는 효과를 얻음
  - 넓은 의미에서 분산 Distributed 처리 시스템의 일종
    - 일반적으로 여러 독립된 시스템을 네트워크로 연결
    - 시스템 하나에 처리하는 놈을 여러 개 두는 : 간결화 시스템 : 버스로 연결, Tightly-Coupled
    - 시스템을 독립시켜놓고 네트워크로 연결하여 분단 처리 : 약결합 시스템 Loosely Coupled

- 병렬 처리  
  - 대칭형과 비대칭형 다중 처리기 시스템
    - 대칭형 다중 처리기 시스템 SMP Symmetric Multi-Processor System
      - 처리기들의 역할 범위가 동등, 즉 마스터-슬레이브 개념 없음
      - 어느 처리기나 사용자 영역과 시스템 영역 실행 가능
        - 운영체제에 부담
        - 동시에 시스템 영역을 사용하면 경쟁 상태 발생 가능
      - 처리기 하나가 고장나도 작동
    - 비대칭형 다중  처리기 시스템 ANP Asymmetric
      - 마스터 처리기와 슬레이브 처리기 지정
      - 시스템 영역은 마스터 처리기만 실행 가능
      - 마스터 처리기가 고장나면 시스템 전체 스톱  
      - 운영체제 부담, 구현 난이도 감소
      - 마스터 고장나면 대책이 없다

- 처리기들 간 버스 연결 방식 (강결합 시스템)
  - 단일 공유 버스 Single Shared Bus
    - 시스템 전체적으로 하나의 버스를 두고 처리기들이 경쟁하여 사용  
      - 배타적으로, 하나가 버스를 쓰고 있다면 (데이터를 주고 받고 있다면), 다른 하나가 버스를 사용할 수 없다 (데이터가 깨지니까)  
    - 처리기를 너무 많이 탑재하면 성능이 오히려 저하
      - CPU를 여러 개 꽂아도, 대기 시간이 존재하기에 성능 향상이 점점 줄어든다
    - 멀티 코어 처리기는 처리기들을 하나의 칩으로 통합하여 버스 경쟁, 캐시 정책, 전력 소모 등을 최적화
  - 다중 버스 Multiple Bus
    - 버스를 여러 개 두고 버스 경쟁률을 완화
    - 메모리를 버스 개수 만큼 나눈다
    - 은행 창구처럼, 톨 게이트처럼, 하나의 버스가 사용중이면 다른 버스로 메모리에 접근
  - 크로스 바 스위치 버스 Crossbar Switch Bus
    - 메모리를 여러 개의 모듈 (뱅크)로 분리
    - 모든 처리기와 메모리 모듈 사이에 독립적인 버스 경로 가능
    - 버스 경쟁으로 인한 성능 저하 최소화
    - 같은 버스 수로 다중 버스의 효과를 내면서
      - 같은 메모리 뱅크를 사용하지 않는 한
      - 대기 시간이 있기는 있음
  - 계층적 버스 Hierarchical Bus
    - 처리기별로 로 접근컬 메모리, 로컬 디바이스, 로컬 버스를 두고, 대부분로컬 버스로 처리
    - 시스템 메모리 접근이 필요한 경우에만 브릿지 컴포넌트를 통해 시스템버스를 사용
    - 글로벌 메모리에 있는 변수 접근 시 대기 시간
    - 소프트웨어 적으로도 (컴파일러) 여러 기능 필요
      - 시스템 메모리로의 주소 바인딩
  - 다중 포트 메모리 Multi Port Memory
    - 메모리에 접근 포트를 여러 개 두고 각각 독립적으로 경로 가능, 접근 가능
    - 각 처리기 별로로 독립된 버스를 분리된 메모리 포트에 연결하여 각각의 병렬 접근을 허용
    - 보통 듀얼 포트
    - 비디오 RAM (VRAM)이 대표적 사례
      - CPU 각 픽셀의 색 설정
      - GPU 각 픽셀을 모니터에 출력
      - 메모리 버스를 가지고 경쟁, 하나가 느리면 병목 현상, 끊어보인다던지  
      - 그래서 메모리도 크고, 다중 포트  

- #메모리는 여러 종류
- #메인 메모리, 비디오 메모리 등

- 분산 처리 (약결합) 시스템
  - 여러 개의 독립된 시스템을 네트워크로 연결
  - 주어진 일을 분담하여 병렬 처리
  - 다중 처리기 시스템도 넓은 의미에서 분산처리 시스템 -> 강결합 시스ㅡ템
  - 보통은 약결합 시스템 혹은 클러스터라고 함
- 분산 처리 시스템의 목적
  - 처리량 향상, 자원 활용도 향상, 시스템 신뢰도 향상, 점진적 시스템 확장
- 분산 처리 시스템의 제공 기능
  - 위치 투명성(분리 된 것이 아니라 우리, 하나로 보이게), 고장 투명성(고장나도 모르고), 접근 투명성(차이가 있어서는 안된다), 중복 및 이동 투명성(중복이어도, 시스템 A에서 B로 옮겨지더라도 사용자가 모르고 쓸 수 있게)

- 분산 처리 시스템의 연결 방식
  - 하이퍼큐브 Hyper Cube
    - 하이퍼 큐브 연결방식이 대표적
    - 8 노드 (시스템)인 경우 각 노드는 3개의 인접 노드를 가짐
    - 16노드인 경우 각 노드는 4개의 인접 노드를 가짐
  - 완전 연결 Fully Connected
    - 초기 설치 비용이 큼
    - 사이트 확장 비용이 큼
    - 사이트 간 통신 속도가 빠름
    - 선로 고장에 따른 신뢰도가 높음
  - 성형 Star
    - 초기 설치 비용 적음
    - 가운데 중계 시스템의 부하 과대
    - 중계 시스템의 고장에 따른 신뢰도 저하
    - 사이트 추가 비용이 적음
  - 링형 Ring
    - 완전 연결과 성형의 절충
    - 초기 설치와 사이트 확장 비용이 비교적 저렴
    - 두 개 이상의 사이트 고장은 네트워크 양분

- NOS

---

- 실시간 시스템 RealTime Systems
  - 프로그램의 처리 마감 시한을 보장하느 시스템 (실시간 처리 환경)
    - 어떤 사건 Event을 기다리는 프로그램에게, 사건 발생 시각부터 처리 완료 시까지의 최대 소요시간 한계를 보장
      - -> 사건이 발생했는데도 불구하고 해당 프로그램의 실행이 오래도록 지연된다면?
  - 경성 실시간 시스템 Hard Real-Time Systems
    - 프로그램의 처리 마감 시한을 원래의 개념대로 엄격하게 보장
  - 연성 실시간 시스템 Soft Real-Time Systems
    - 프로그램의 처리 마감 시한을 원래의 개념대로 엄격하게 보장하지는 못하지만, 해당 프로그램의 처리 지연을 최소화 시킬 수 있음.
    - 범용 운영체제인 유닉스, 리눅스, 윈도우 등에서 실시간성 프로그램을 분류하여 관리

---

- 컴퓨터 시스템 주요 구성 요소  
  - 중앙처리장치 CPU Central Processing Unit  
  - 주기억장치 Main Memory  
    - 왜 '주' 기억장치냐, CPU가 직접 참조  
  - 주변 장치 Peripheral Device  

- processor (프로세서)
  - 처리기, 일반적으로 중앙처리장치 (CPU) = 명령어를 해석하는 컴퓨터의 한 부분  
  - 그래픽처리장치 (GPU) 도 컴퓨터의 일부이지만 단지 '프로세서' 라는 용어만 사용하였을 때 그래픽 처리 장치를 뜻하는 경우는 아직 많지 않음  
  -
- MainBoard, MotherBoard, SystemBoard
  - 다 똑같은 용어, 우리나라는 보통 메인보드라 칭하고, 해외에서는 마더보드라 칭하는 경우가 많음

- @여치
- 버스 Bus
  - CPU(CPU Pin) - Bus(전선, PCB 기판에 붙어있는 얇은 박막) - Memory or 주변 장치
  - 엄밀히 따져 딸랑 선만 놓고 버스라고 하진 않지만.
  - 데이터 버스만 가지고 신호를 주고 받을 순 없고, 어드레스 버스도 같이 따라다닌다

- 시스템 버스 System Bus  
  - 어드레스 버스 Address Bus  
    - 메모리나 입출력 장치에 접근할 때 접근 장소를 식별하기 위한 주소를 전달  
    - 메모리 크기에 따라 8 16 24 32 64 비트(라인) 등의 크기를 가짐  
  - 데이터 버스 Data Bus (R/W)  
    - 메모리나 입출력 장치에서 데이터를 보내거나 읽어올 데이터를 전달  
    - 데이터 전송 대역폭에 따라 8 16 32 64 비트(라인)등의 크기를 가짐  
  - 제어 버스 Control Bus (R/W하는 명령/신호 같은)  
    - 메모리나 입출력 장치 등에 읽기/쓰기 등의 기능을 제어하기 위한 신호 전달  
    - 신호의 종류에 1/2/3 비트 (라인) 등의 크기를 가짐  

- RAM Random Access Memory  
  - 임의의 주소에 접근  

- I.E. 8라인 = 2의 8승 = 256B  
- I.E. 16라인 = 2의 16승 = 64KB  
- I.E. 32라인 = 2의 32승 = 4GB  
- 2의 10승 = 1024 = 1K  

- 주기억장치 Main Memory
  - 비트 Bit 와 바이트 Byte
    - 비트 0/1을 기록하는 메모리의 최소 구성 소자
    - 바이트 : 8비트로 구성되면 256가지의 서로 다른 정보 저장 가능
  - 바이트 별 주소 지정
    - 대부분의 컴퓨터는바이트 단위로 주소를 부여
  - 바이트 단위 저장
    - 읽거나 쓰기는 반드시 바이트 단위로 이루어짐
  - 1/2/4/8 바이트 동시 접근 (읽기/쓰기)
    - 기계 명령어 Machine Instruction 에 따라 동시 접근하는 바이트 수가 다름  
  - 메모리 얼라이먼트 Memory Alignment
    - 2 4 8 등의 바이트 동시 접근 시 목표시작 주소를,  
    - 2 4 8의 배수가 되도록 요구하는 기계 CPU 가 있음  
    - #1 바이트는 어디서든 되는  

- 기계 명령어 Machine Instruction
  - CPU가 처리하는 명령어 단위
    - 고급 언어로부터 번역되어 실행 시 메모리에 적재
    - CPU에 의해 인출되어 처리됨
  - 연산코드 Operation Code 와 피연산자 Operand
    - 연산 코드는 피연산자에 적영할 덧셈, 뺄셈 등의 연산을 의미하는 코드
    - 피연산자는 연산에 사용될 값을 의미
    - 피연산자로 주기억장치 주소, 상수 ,CPU 레지스터 번호 등이 가능
    - = 위와 같이 다양한 형태의 피연산자를 어드레싱 모드 ADdressing mode라 함
    - 피연산자 부분의 크기는 주기억장치의 크기에 영향을 받음
    - #전형적인 기계 명령어 포맷 연산코드 4비트+피연산자 12비트  
    - #피연산자 최대 크기에 맞춰서  

- 주변 장치 Peripheral Device
  - @여치
  - I/O
    - CPU 입장에서의 입출력
    - 사람의 뜻 (조이스틱, 마우스, 키보드 등)을 CPU에, CPU의 뜻 (산술연산 결과, 디스크에 저장된 이쁜 누나 사진 등의 데이터)을 여러분에게 전달하기 위해서(일반적으로 모니터를 통해서)는 반드시 입출력이 필요한 것이다.
    - CPU 입장에서 봤을 때 메모리에 쓰고 읽어오는 것 자체도 I/O지만, 통상 I/O라고 주변 장치들과의 입출력

---

### (CPU) 명령 사이클 (기계 사이클)

[참고](https://gamedevlog.tistory.com/71)  

Instruction : 명령, (사전 = 지침)  

- Fetch (=bring) 인출
  - CPU가 명령을 수행하기 위해 그 명령어를 레지스터에서 꺼내 오는 것
  - 위 말고도 그냥 일반적으로 가져온다는 뜻으로 많이 쓰이기도 하는 듯

- (CPU) 명령 사이클 Instruction Cycle (기계 사이클 Machine Cycle)  
  - CPU의 일과
    - Memory(#주기억장치)로부터 끊임없이 기계 명령어를 주소 번호대로 (차례로) 인출, 해당 명령어가 요구하는 동작을 수행/처리  
    - 점프를 의미하는 기계 명령어를 만나면 명령어 인출 위치를 변경
  - 인출 사이클 Fetch Cycle
    - 이번 차례 주소(PC가 가르키는 곳)의 주 기억장치에서 명령어를 읽어 옴
    - 인출이 완료되면, PC는 다음 차례의 명ㄴ령어 주소로 업데이트됨
  - 해독 사이클 Decoding Cycle
    - 연산 코드를 분석하여 어떤 연산인지를 식별함
  - 피연산자 사이클 Operand Cycle
    - 피연산자 인출이 필요한 경우 지정된 곳에서 피연산자를 읽어옴
  - 실행 사이클 Execution Cycle
    - 누산기와 피연산자 사이에 연산을 적용하여 명령어를 실행
  - #더 세부적으로 나눌 수도 있고, 각 단계를 더 나눌 수도 있음 (마이너 사이클 or Micro Operation != 메이저 사이클)
  - #톱니바퀴형 파이? 클럭 (CPU 파형)?

- @여치
- 클럭 CLOCK
  - CPU와 같은 전자회로는 내부적으로 동기(Sync.)가 맞아야한다.
  - 회로는 이전의 데이터값에 영향을 받아 작동하므로 이전상태를 [기억]하고 있어야하며 이전 상태와 현재 상태를 가르는 기준으로, 클럭이라 부르는 사각파 전기신호를 사용
  - 파형의 한 주기가 한 클럭, 한 주기가 바뀔때마다 새로운 상태 (개념적으로, 이전 상태와 현재 상태가 같을 수 있음)
  - 명령어는 한 클럭(한 주기)만에 완료되는 것도 있지만, 아닌것도 많다.
    - 회로구성이 이전 상태 (이전 주기)를 필요로 하는 명령
    - 메모리 칩 등 속도가 느린 장치를 억세스할때 속도를 맞추기 위해 대기
  - I.E. 2.4GHz 펜티엄 4, 2.4GHz = 클럭 주파수, 초당 24억번 클럭 주기

- 레지스터 Register
  - 레지스터 Register란?
    - @여치 : CPU 내의 Memory, CPU의 각 상태 저장, 데이터 이동/연산의 기본 = 프로그래머가 짠 코드는 레지스터를 제어하는 코드
    - 메모리와 달리 불규칙적, 소량
    - 단순한 값의 저장 기능 외에, 저장 값에 따라 하드웨어 등의 상태에 영향을 미침
    - 레지스터는 CPU 내 번호, 주기억장치 주소의 일부 영역, 입출력 포트 번호 등에 의해 접근됨
  - 레지스터의 유형
    - CPU 레지스터
      - CPU 내에서 위치하여 CPU 제어, 연산 (누산기) = A Register, 값의 임시 저장 용도 = S Register 로 사용
      - #A, PC, MBR, MPN | S, T
    - 특수 기능 레지스터 SFR Special Function Register
      - 컴퓨터 전반에 걸친 상태를 설정하거나 현재 상태 표시
    - 입출력 레지스터
      - 입출력 장치와 연결되어 입력이나 출력할 때 데이터 전달 통로 역할

- @여치
- 인텔계 x86 cpu는 메모리->메모리 전송도 가능하지만 그 외 상당수 CPU는 데이터 이동에서도 레지스터를 거쳐야만 하지만

- 주소 지정 모드 Addressing Mode
  - 주소 즉시 Address Immediate 주소 지정 모드
    - 주소 모드
      - 피연산자에 나타난 값을 주소로 해석함 (직접 간접, 절대 상대 주소 해당)
    - 즉시 모드
      - 피연산자에 나타난 값은 상수로 해석함
  - 직접 간접 Direct Indirect 주소 지정 모드
    - 직접 주소
      - 기계 명령어의 피연산자 부분이 주기억장치 접근 주소로 사용되는 경우
      - #주소 -> 값 가져옴
    - 간접 주소
      - 피연산자 부분이 가르키는 곳에 저장된 기억장치 같이 2차(최종) 주소로 사용되는 경우
      - #주소 -> 주소 -> 값 가져옴 Like 포인터
  - 절대 상대 Absolute Relative 주소 지정 모드
    - 절대 주소
      - 피연산자에 나타난 주소가 그대로 주기억장치 접근 주소로 사용되는 경우
      - #주소 -> 값 가져옴
    - 상대 주소
      - 피연산자에 나타난 주소에 제 3의 기준 값을 더한 값이 주기억장치 접근 주소로 사용되는 경우
      - #주소 + 기준 값 -> 값 가져옴

- OP Coder 연산 코드, Operand 피연산자  
- I.E. Add_절대/상대_직접/간접, 상수  

---

[참고 0](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8_%ED%95%B8%EB%93%A4%EB%9F%AC)  
[참고 1](https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)  

- 인터럽트 Interrupt (가로채기, 처리 중간에 방해/중단되고 다른 일을 잠시 처리, 큰 틀에서 봤을 때 처리하는 일은 변함 없음)  
  - #CPU에서 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에게 알려 처리할 수 있도록 하는 것
  - CPU에 전달되는 사전 신호 Event Signal
  - 사건 신호에는 여러 가지가 있으며, 주로 각각의 전용 회선으로 전달됨 (Source I.E. 키보드 마우스 등)
    - Vectored Interrupt
  - 전용 회선이 없는 경우, 어떤 인터럽트가 발생했는지를 탐색해야 함
    - Interrupt Polling(Polling Interrupt)

- != [Polling (폴링)](https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))
  - 폴링은 하나의 장치 혹은 프로그램이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치 혹은 프로그램의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 소우신 등의 자료처리를 하는 방식
  - 인터럽트는 대상을 주기적으로 감시하여 상황이 발생하면 해당처리 루틴을 실행해 처리하는 폴링과는 달리, 상대가 CPU에게 일을 처리해 달라고 요청하는 수단

- ISR, Interrupt Service Routine Or Interrupt Handler

- 인터럽트 우선 순위 Interrupt PRiority
  - 여러 개의 인터럽트가 동시에 발생한 경우 대응 처리 순서를 결정함
  - 기 발생한 인터럽트에 대한 대응 처리 도중, 다른 인터럽트가 발생했을 때, 그 인터럽트를 보류 시킬 것인지 아니면 지금 즉시 처리할 것인지를 결정함
    - 새로 발생한 인터럽트의 우선 순위가 더 높으면 진행 중이던 대응 처리를 잠시 유보하고 새로운 인터럽트 처리를 먼저 처리한 후 재개함
- 인터럽트 사이클 Interrupt Cycle
  - CPU가 인터렙트 발생 여부를 체크(조사)하는 시기를 말함
  - 4단계의 명령/기계 사이클을 마치고 인터럽트 발생 여부를 조사함
    - 즉, 하나의 기계 명령어에 대한 처리를 마칠 때마다 조사함
    - 결국, 명령/기계 사이클은 인터럽트 사이클을 포함하여 총 5단계로 이루어져 있음

- 인터럽트 유형
  - 디바이스 인터럽트 Device Interrupt
    - 입출력 장치 등 CPU 외부 주변 기기에서 발생하는 인터럽트
      - 하드웨어 인터럽트 HW Interrupt 라고도 함
    - 오류 인터럽트 Error Interrupt
      - CPU가 기계 명령어를 처리하는 도중에 발생하는 인터럽트
      - 잘못된 기계 명령어를 만나거나 0으로 나누는 등의 연산 불가 상황에서 발생
        - 예상하지 않는 오류 발생이란 뜻에서 예외 Exception라고 함
    - 소프트웨어 인터럽트 SW Interrupt
      - 인터럽트를 발생시키는 기계 명령어, 즉 프로그램에 의해 발생된 인터럽트
      - 인터럽트 대응 처리를 테스트하거나, 시스템 콜을 위해 사용자 프로그램에서 운영체제로 진입하기 위해 사용
        - 프로그램의 흐름을 인위적으로 특별한 부분으로 빠져들게 하므로 트랩 Trap 이라고도 함

- 이중 모드 Dual Mode Operation  
  - CPU가 사용자 영역과 시스템 영역을 드나드는 것  

- CPU의 실행모드
  - 시스템 모드 System Mode
    - CPU가 운영체제 부분을 실행할 때 설정되는 모드
      - 특권 모드 Privileged Mode 또는 수퍼바이저 모드라고도 함
  - 사용자 모드
    - CPU가 사용자 프로그램을 실행할 때 설정되는 모드
      - 단순히 프로그램 모드라고도 함
- 특권 명령어 Privileged Instruction
  - 시스템 모드에서만 실행 가능한 기계 명령어
  - 사용자모드에서 실행될 경우 예외 발생
  - 입출력 명령어 등 시스템 보호 및 유지를 위해 필요
- 모드간 이동
  - 시스템 모드에서 시작(부팅과정)
  - 시스템 모드 -> 사용자 모드
    - 운영체제가 사용자 모드로 변경하고 사용자 프로그램으로 점프
  - 사용자 모드 -> 시스템 모드
    - 시간 초과 등의 인터럽트에 의해 운영체제 내 ISR 로 점프하면서 설정

- 입출력 장치 IO Device
  - 입력 Input
    - CPU, DMA 등 처리기가 주변 장치의 데이터 레지스터 Data Register로부터 데이터 값을 읽어 주기억장치로 복사하는 작업
    - 데이터 레지스터로부터 값을 읽을 때에는 상태 레지스터 Status Register의 데이터 준비 상태를 확인해야 함
      - 준비되지 않은 상태에서 읽을 경우 엉터리 값을 읽게 됨
  - 출력 Output
    - 입력과 반대로 주기억장치으 데이터 값을 읽어 주변장치의 데이터 레지스터로 복사하는 작업
    - 데이터 레지스터에 값을 쓰기할 때에는, 상태 레지스터에서 이전 데이터의 출력이 완료되었는지 확인해야 함
      - 이전 데이터의 출력 완료 전 또 다른 데이터를 쓰기하면 출력 데이터의 정확성이 보장되지 않음

- 입출력 장치 구조
  - 입출력 장치 제어기 IO Device COntroller 입출력장치인터페이스
    - 상태 레지스터 Status Register
      - 데이터가 입력되었는가 혹은 데이터 출력이 완료되었는 가 등 장치의 상태를 표시하는 곳
    - 명령 레지스터 Command Register
      - 입력 혹은 출력 하라는 등의 명령을 보내는/쓰는 곳
      - 입력 명령에 따라 입력 => 동기적 입력 (디스크 등)
      - 입력 명령없이 수시로 입력 => 비동기적 입력 (키보드 등)
      - 출력은 언제나 동기화
    - 데이터 레지스터 Data Register
      - 입력된 데이터나 출력될 데이터를 임시 보관하고 있는 곳
    - 입출력 장치 구동기 IO Device Driver
      - 장치 제어기 인터페이스를 이용하여 입출력을 처리하는 소프트웨어

- 입출력 장치의 식별
  - 메모리 대응 입출력 Memory Mapped IO
    - 입출력 장치의 레지스터들의 위치를 주기억장치의 주소영역 일부에 대응
    - 주기억장치 (변수, 주소)에서 읽고 쓰기하는 동일한 방법으로 입출력이 이루어짐
    - 즉, 메모리 접근 명령어와 동일한 기계 명령어 (load, save 등)를 사용하여 입출력을 진행함
      - 개발자 입장에서 편리하나, 메모리 공간의 일부는 사용할 수 없음

- 입력 예  
  - load r1, 10
    - 메모리 10번지에 대응된 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)
  - save r1, 1000  
    - 입력된 데이터를 메모리 1000번지에 저장
- 출력 예
  - load r1, 2000
    - 메모리 2000번지의 데이터를 CPU의 r1 레지스터로 적재
  - saver1, 20
    - 적재된 데이터를 메모리 20번지에 대응된 출력 레지스터에 기록 (출력)

- 격리된 입출력 Isolated IO
  - 주기억 장치의 주소 영여과 별개로 입출력 장치 주소 영역 (포트, Port)이 따로 있음
  - 즉, 메모리 10번지와 입출력 포트 10의 숫자는 동일하지만 지시하는 위치는 전혀 다름
  - 따라서, 메모리 접근 기계어 외에 입출력 포트 접근을 위한 전용 기계 명령어 (in, out 등)가 필요함
  - = 메모리 공간을 모두 사용할 수 있으나, 시스템 설계가 다소 복잡해짐

- 입력 예  
  - in r1, 10
    - 입력 포트 10번지의 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)
  - save r1, 1000
    - 입력된 데이터를 메모리 1000번지에 저장
- 출력 예
  - load r1, 2000
    - 메모리 2000번지의 데이터를 CPU의 r1레지스터로 적재
  - out r1, 20
    - 적재된 데이터를 메모리 20번지인 출력 레지스터에 적재 (출력)

- 컴퓨터 저장장치
  - 컴퓨터에 사용되는 저장장치는 가격, 성능, 용량에 따라 계층을 이루고 있다

CPU 레지스터 CPU Register  
캐시 Cache { S-RAM Static }  
주기억장치 Main Memory { D-RAM Dynamic Random Access Memory }  
전자디스크 Electronic Disk { SSD }  
자기디스크 Magnetic Disk { HDD }  
광디스크 Optical Disk { CD ROM, DVD }  
자기테이프 Magnetic Tape  

- 레지스터
  - CPU내에 존재하는 연산 및 임시 저장 용도의 저장 공간
- 캐시
  - CPU와 주기억장치 사이의 속도차 극복을 위한 소량, 고속, 고가 메모리
  - 프로그램의 지역성 특성에 의거 90% 이상의 적중
    - #500번지에 접근한다고 할 때, 또 다시 500번지에 접근할 가능성이 높음
    - #때문에 캐시에 적재하는 것이 비효율적이지 않다  
- 전자 디스크
  - 플래시 메모리 기술에 기반한 SSD Solid State D

- Memory (메모리)
  - 레지스터(CPU) - 캐시메모리 - 주기억장치 - (캐시메모리) - 보조기억장치
  - 일반적으로 용량과 속도 반비례, 속도와 용량 대비 가격 비례

  - 레지스터 데이터 읽기 = 머릿속에 있는 기억 떠올리기
  - 주기억장치 데이터 읽기 = 책장에 꽂혀 있는 책에서 특정한 책을 찾아 내용을 읽는 행동
  - 보조기억장치 데이터 읽기 = 지구를 한 바퀴 돌아서 특정한 내용 찾아오기

  - @여치
  - 임시 기억 장소, 기억장치 대신에 책상, 즉 작업공.
  - 책상이 크면 그만큼 많은 것들을 올려놓고 작업할 수 있으니 빠르고 편하다. 책상이 손바닥만하다면 뭐 하나 하려고 하면 올렸다 내렸다 손은 바쁘게 움직이되 일 전체는 느려질 것이다.
  - 메모리에 뭔가를 저장하고 다시 꺼내오려면, 주소(Address)가 필요하다. Like 물품 보관소  

  - [메소드 스텁](https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C_%EC%8A%A4%ED%85%81)  

- register (레지스터)
  - 프로세서에 위치한 고속 메모리
  - 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역
  - 컴퓨터 구조에 따라 크기와 종류가 다양

문제 4-2 명령어  
한 자리씩 오른쪽으로 밀린다, 가장 오른쪽에 있었던 것은 가장 왼쪽으로 간다.  

- 입출력 개관

- 입출력 과정
  - 응용 프로그램의 입출력 요구 => 운영체제 => 입출력 장치 (입출력 하드웨어) 인터페이스
  - 디스크, 키보드, 모니터, 인터넷 통신, 블루투스 통신, 시리얼 통신  

- 직접 데이터 입출력과 간접 데이터 입출력
  - 직접 입출력
    - 운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공없이 그대로 전달
    - #RAW Device
    - #Special File (!Regular File)
    - #Major Number, Minor Number
  - 간접 입출력 (대부분이)  
    - 운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공하여 전달  
    - #계층적 저장구조를 위해서  
    - #파일 시스템
    - #TCP/IP 프로토콜 네트워크 패킷(헤더) 같은 걸 붙이는  

- 문자 Character 입출력 장치와 블록 Block 입출력장치
  - 문자 입출력 장치
    - 바이트 단위의 가변적 크기의 입출력 (키보드, LAN 등)
  - 블록 입출력 장치
    - 디스크의 512바이트 단위 입출력과 같이 일정한 크기의 블록 단위 입출력  
    - #하드디스크는 한 바이트를 수정하려면 그 바이트가 포함된 한 섹터를 수정하고 전체를 덮어씌워야 함  

---

파일 기술자 File Descriptor : 파일의 상세 정보에 대한 지시자  

- 파일 입출력 절차 (유닉스/리눅스)
  - 입출력 시스템 호출 (시스템 콜)
    - Open Read Write Close  
    - SW 인터럽트 기법으로 OS에 진입
    - Copy in  
      - 사용자 영역 => 운영체제 영역 방향으로 데이터 복사
    - Copy-out
      - 사용자 영역 <= 운영체제 향으로  

- fd  = open("path", ...) <= 파일 기술자
- n = read(fd, buf, size)
- n = write(fd, buf, size)
- close(fd)

- 파일 테이블

- 대기 입 출력 Blocking IO과 비대기 입출력 Non-Blocking IO

- 입력 대기 방안
  - n = read(fd, buf, size)
    - 1바이트라도 입력될 때 까지 대기 -> Blocking IO
    - size 바이트까지 대기 -> Blocking IO
    - 입력이 없으면 대기없이 오류 리턴 -> Non-Blocking IO

- 출력 대기 방안
  - n = write(fd, buf, size)
  - 1 바이트라도 출력될 때까지 대기 -> Blocking IO
  - size 바이트까지 대기 -> Blocking IO
  - 현재 출력이 불가능하면 대기 없이 오류 리턴 -> Non-Blocking IO

- 왜 중요하냐, 인터넷에서 클라가 어떤 포털 사이트에 로그인을 신청하면 이 프로그램은 이제 뭘 받아야해 아이디하고 패스워드를 읽어들어야겠지 그게 이걸로 하는거야 인터넷에서는 read 대신 receive도 가능, 서버 입장에서는 합리적인 시간 내에서 입력을 받아야 하겠지, 근데 클라가 만약에 입력을 안해 그러면 요 방시그올 (Block) 운영체제를 운영하고 있다면, 입력이 없으니까 입력 대기 상태에서 멈춰있겠지, 한 사람이면 문제가 없는데 클라가 많은 사람이 연결해서 입력을 안하고 있다면.., + 접속할때마다 메모리도 할당을 해주는데 그게 안딘다, DOS 고의로 연결을 하고 입력을 안하는것, 그래서 Non-Blocking 방식으로, 어느 일정 시간 동안 입력이 없으면 끊어버림, 그런것과 관련이 있다  

- 입출력 장치 구동기 (드라이버 드라이버 Device Driver)
  - 메모리 대응 입출력, 격리된 입출력
  - 동기 입력
    - 디스크 등과 같이 데이터가 컴퓨터 내부에 저장되어 있는 경우
    - 명령 레지스터에 '읽기' 명령을 명시적으로 설정
  - 비동기 입력
    - 키보드, LAN 등과 같이 데이터가 컴퓨터 외부에서 언제 얼마만큼의 데이터가 입력될 지 예측할 수 없는 경우
    - 상태 레지스터의 '준비' 상태로만 확인하여 입력
  - 동기 출력
    - 출력은 항상 동기식으로만 이룽짐
    - 명령 레지스터에 '쓰기' 명령을 명시적으로 설정

- 프로그램 입출력 (바쁜 대기 입출력 Busy-waiting I/O)  
- 입출력 장치를 반복구문으로 지속적으로 체크하여 입출력  

---

- 인터럽트 기반 입출력 Interrupt-Driven I/O  
- 입출력 완료 인터럽트 활용  
- vs Busy-Waiting  
  - 계속 기다리지 않고, 입력이 왔을 때에만 잠깐잠깐 다른 일  
  - CPU 효율 증가

- ISR Interrupt Service Routine

- DMA (Direct Memory access) IO
- 입출력 전담 처리기 활용  

- 입출력은
- 단순히 외부 장치의 3가지 레지스터중 Data 레지스터에 대해  
- 레지스터에서 메모리로 데이터 복사 = 입력
- 메모리에서 레지스터로 데이터 복사 = 출력

- DMA는 위 내용만 할 수 있는  
- (Address, Count, Command)  
- vs Busy-Waiting  
  - CPU를 더 불려먹을 수 있다  
  - 주기억장치가 주기억장치인 이유는 CPU가 메모리에 접근하기 때문인데,  
  - DMA도 CPU처럼 직접 메모리에 접근하여 데이터를 넣거나 빼거나  
  - = Direct Memory Access

- 입출력 채널 IO Channel
  - 입출력이 지나가는 통로  
  - IOP IO Processor 라고 부르기도 함
  - DMA도 채널 중이 하나임
  - 실렉터 채널, 멀티플렉서 채널, 블록 멀티플렉서 채널 등의 유형이 있음  
  - Selector Channel 한 번에 하나 (속도가 빠름), Multiplexer Channel 병렬 처리 (속도가 느려서), Black Multiplexer Channel

---

- 버퍼 Buffer  
  - 임시 보관 장소  
  - ~= Cache 좀 복사가 빠른 곳에 두는 임시 보관 장소  

- 프로세스 및 스레드 관리

- 프로세스
  - 프로그래밍 언어로 작성된 프로그램이, 목적 코드로 (기계어 코드)로 번역되어 디스크에 저장된 후 운영체제의 도움으로 주기억장치에 적재되어 실행 중인 프로그램
  - 한 마디로 메모리에 적재되어 실행 중에 있는 프로그램  

- 프로세스 속성
  - 고유 번호 PID Process Identification Number  
  - 메모리 정보  
  - 상태 Status  
  - 진행지점 Counter  
  - 문맥 Context  
  - 우선순위 Priority  
  - 자원목록 Process Resource 
  - 회계정보 Accounting Information  
  - 기타  

- LDA x  
- ADD y  
- STA z  
- -> z = x + y;  

- 중간이 타임아웃이 되면 그 시점의 스냅샷을 저장하고  
- 다시 돌아왔을 때 불러와 실행, 연속성  
- 저장하는 CPU의 내용 = 문맥 Context  

- 프로세스 관리 블록 PCB  
  - 프로세스는 OS의 관리 대상  
    - 프로세스가 하나의 개체로 등록됨  
    - 프로세스에 관한 모든 정보가 PCb에 기록되어 관리됨  
    - PCB의 총 개수가 곧 관리 가능한 최대 프로세스의 수를 의미함  

- 프로세스 관리 (상태 천이)
  - 운영제체는 프로세스의 처리과정에서 프로세스의 활동에 따라 해당 프로세스를 적절한 상태로 천이 시킨다
  - @실행 상태가 아닌 모든 프로세스는 해당 상태의 대기열에 관리된다

- 프로세스 상태
  - 준비 Ready 상태
  - 실행 Running 상태
  - 대기 Blocked 상태
  - 보류 Suspended 상태
  - 대기-보류 Block-Suspended 상태
  - 종료 Terminated 상태 (Dispatch 배급하다)

- 스레드 Thread (실)
  - 프로그램이 실행되는 흐름 줄기
  - 보통 프로세스는 하나의 실행 줄기 즉, 하나의 스레드를 가짐 (단일 스레드 프로세스)
  - I.E. C 프로그램의 main() 함수에서부터 시작하는 실행줄기

- 다중 스레드 프로세스 Multi Thread Process
  - 다중 스레드 프로세스 개념
    - 프로세스는 하나이지만, 여러 개의 실행 줄기(스레드)를 가짐
    - OS는 스레드 별로 독립적인 상태 천이를 관리함
    - 즉, 스레드 별로 ~

~

- CPU가 반드시 여러 개일 필요는 없음
- CPU가 여러 개일 경우는 스레드들이 병렬처리됨
- CPU가 하나일 경웅는 스레드들이 병행처리됨

- LDA | 100
- 주소 100

- LDA_S | 100
- 주소 100 + Stack Pointer
- 상대주소기법

- 스레드 생성 및 제거

- 프로세스 생성 및 제거
  - 프로세스 생성
    - 새로운 프로세스는 이미 실행 중인 다른 프로세스가 OS에 오청함으로써 탄생
    - 이들은 부모 프로세스 Parent Process의 자식 프로세스 Child Process 관계가 됨
    - 단말기 (키보드) 사용자들은 실행하고자 하는 프로그램의 이름을 쉘 (명령어 해석기)에 전달하여 쉘로 하여금 프로그램 생성을 OS에게 요청하도록 함
    - 디스크 프로그래믕 메모리로 적재하여 프로세스를 생성하는 OS부분을 로더 Loader 라함

- 프로세스 제거
  - 정상적인 프로세스 제거는 해당 프로세스 스스로가 운영체제에게 요청함으로써 이루어짐

---

@0406  

- 프로세스 간 통신 IPC InterProcess Communication
  - 일반적인 프로세스들은 완전히 독립되어 다른 프로세서들과 격리되어 정보를 교환할 수 있음
  - 거대한 프로그램을 작게 분리한 경우, 이를 프로세스 간의 통신 수단이 요구됨
    - 클라이언트 Client -> 서버 모델
  - 대표적인 통신 수단을 파이프, 메시지, 큐, 공유 메모리, 세마포, 소켓(인터넷)을 들 수 있음
  - 통신 경로는 운영체제에 의해 제공되기 때문에 각각의 통신 수단마다 고유의 셋업 절차를 따라야 함

- 프로세스 통제
  - 실행중인 프로세스에 대한 어떤 조치를 취하는일

- 프로세스 통제수단
  - OS가 제공하는 서비스 (씨스템 콜)을 이용
  - 유닉스/리눅스의 경우 kill() 시스템 콜

- 프로세스 통제 유형
  - 강제 종료 :
    - 실행중인 프로그램이 스스로 종료하기 전에 무조건 강제로 종료하도록 한다
  - 일시 정지 :
    - 완전히 종료하도록 하느 것은 아니고, 임시로 CPU의 할당을 받지 못하여 더 이상의 실행이 이루어지지 않도록 한다
  - 실행 제개 :
    - 일시 중지 상태에 있는 프로세스가 CPU를 할당 받아서 계쏙 수행할 수 있도록 한다.
    - 우선 순위에 따라 다른 프로세스와 공평하게 CPU를 할당받는다
  - 약속 처리 :
    - 프로그램을 작성할 때 약속했던 처리 부분들을 실시간으로 지시한다
  - 우선 순위 변경 :
    - 실행중인 프로그램의 우선순위를 올리거나 내린다.
    - 일반 사용자는 내리기만 가능하고,관리자는 양쪽 모두 가능하다.

- 프로세서 CPU 관리

- 프로세서 Processor란?
  - 주기억장치에 저장된 프로그램 (기계 명령어)를 읽어가면서 처리하는 CPU
  - 기타 DMA와 같이 제한된 기능만을 수행하는 프로세서도 있음
  - 처리기로 부르는 경우도 있음

- 프로세서 관리
  - 다수의 사용자 프로그램이 있을 때 (멀티프로그래밍), 어느 프로세스를 선택하여 CPU를 보낼 것인가의 문제
  - CPU 스케쥴링 이라 부르기도함
  - OS 설계자와 추구하는 바에 따라 ~?

- 단계별 처리 스케줄링
  - 장기 스케줄링 Long-Term Scheduling
    - 어느 프로그램을 먼저 적재할 것인가 하는 수준의 스케줄링
    - 잡 스케줄링이라고도 함
  - 중기 스케줄링 Medium-Term Scheduling
    - 메모리에 적재된 프로그램들 중, 상당기간 동안 처리를 보류하여 자원을 확보하는 차원의 스케줄링
    - 대상이 된 프로세스들은 잠시 디스크로 이동하여 기다림 (스와핑)
  - 단기 스케줄링 Short-Term Scheduling
    - 실행 준비가 된 프로세스들 중, 어느 프로세스에게 CPU를 보낼 것인가 하는 수준의 스케줄링
    - 보통 CPU 스케줄링이라 함은 이 수준을 말함 (이후 통일)

---

@0411  

- CPU 스케줄링 전략의 목표 및 기준

- 사용자 관점에서의 기준 (평가 기준)
  - 응답 시간 Response Time
    - 사용자 입력에 대하여 출력이 이루어질 때까지 소요되는 시간
    - 동일한 조건에서 CPU 스케줄링 방법에 따라 달라질 것임
  - 반환시간 Turnaround Time
    - 프로그램이 제출(혹은 적재)된 후 최종 결과물을 얻을 때까지의 소요시간
    - 총 처리시간이라고도 함
  - 대기 시간 Waiting Time
    - CPU가 주어질 때까지 기다리는 시간들의 합
    - CPU는 자주 조금씩 주어짐
  - 지표 분석
    - 사용자들은 세 가지 지표가 모두 짧아지기를 희망

- 시스템 관점에서의 기준
  - CPU 이용률 CPU Utilization
    - CPU가 순수하게 사용자 프로그램을 실행하는데 소요한 시간의 비율
    - 쉬는 시간이나 시스템 자체의 내부 처리를 위해 보낸 시간이 많으면 좋지 않음
    - @ 문맥 교체 등
  - 처리량 Throughput
    - 전체적으로 단위 시간당 처리하는 프로그램의 수
  - 지표 분석
    - 시스템 (컴퓨터 운영자) 입장에서는 두 지표 모두 높이기를 희망

- @ ~ 사용자 관점과 시스템 과점의 두 입장이 상충됨
- 둘 다 잡을 수 없음 = 하나는 조금 희생해야 한다

- 기타
  - 가용성 Availability
    - 전체 시간 (서비스, 고장, 유지보수, 점검 등) 대비 서비스 시간의 비율 (신뢰성, 가동율)
    - 특정 자원에 대하여 즉시 접근할 수 있는 정도 (즉시 접근 가능 빈도 비율)

- CPU 스케줄링이 이루어지는 시기

- 프로세스가 입출력을 요구할 때
  - 진행 중이던프로세스가 입출력을 요구하면, OS는 입출력 진행중인 동안 마냥 기다릴 수 없으므로 다른 프로세스를 선택해서 CPU를 보내야한다.<- 비선점 CPU 스케줄링

- 프로세스가 종료를 요구할 때
  - 프로그램의 진행 절차상 모든 처리가 끝나 종료를 선언하면, OS는 다른 프로세스를 선택하여 CPU를 보내야 한다 <- 비선점 CPU 스케줄링

- 높은 우선 순위의 프로세스가 나타났을 때
  - 높은 우선순위의 프로세스가 입출력을 마치고 준비상태로 전환되면, OS는 현재 실행중인 프로세스를 보류하고, 더 높은 우선 순위의 프로세스에게 CPU를 보낼 수 있다. <- 선점 CPU 스케줄링

- 실행시간이 초과되었을 때
  - 현재 실행 중인 프로세스에게 허용된 최대 실행 시간이 초과하면, CPU는 다른 프로세스 ~여 CPU를 보낼 수 있다. <- 선점 CPU 스케줄링

- 선입 선처리 FCFS First-Come First-Served 스케줄링
  - 개념
    - 준비 대기열 Ready Queue 에 도착한 순서대로 처리
    - 입출력이나 종료 시까지 계속 실행 <- 비선점형
    - 분석

- 최단 작업 우선 SJF Shortest Job First 스케줄링
  - 개념
    - 현재 준비 대기열 Ready Queue에 도착한 프로세스들 중, CPU 버스트 CPU Burst가 짧은 것을 선택하여 실행
    - SPN Shortest Process Next 라고도 함
    - 즉, 입출력이나 종료 시까지 계속 실행 <- 비선점형
  - 분석
    - 기아 상태 현상
    - CPU 버스트는 어떻게 계산?
      - 예측 하는 방법론이 있다 (수업에서 다루지는 않음)

---

@0413  

- 최단 잔여 시간 우선 SRTF Shortest Remaining Time First 스케줄링
  - 개념
    - 실행 중 새로운 프로세스가 도착하면, 현 프로세스의 남은 시간과 새 프로세스의 CPU 버스트 시간을 비교하여 새 프로세스가 더 짧으면 교체 <- 선점형
  - 분석
    - 평균 대기 시간과 평균 응답 시간을 더욱 개선 -> CPU 이용률 저하 현상 발생 억제
    - 반면 기아 상태 발생 가능성 더 높음

- 최고 응답률 우선 HRRF Highest Response Ratio First 스케줄링
  - HRN Highest Response Ratio Next
  - 응답률
    - CPU 버스트 대비 대기열에서 기다린 정도의 검증 (CPU 버스트가 크면 그만큼 많이 기다려도 무바앟다는 취지)
    - 응답률 = (준비큐 대기시간 +CPU버스트 시간) / (CPU 버스트시간) = 1 + 준비큐시간 / CPU 버스트 시간)
    - 선점 혹은 비선점 운영 가능
  - 개념
    - SJF나 SRTF의 기아 Starvation 현상을 해결

- 라운드 로빈 RR Round Robin 스케줄링
  - 개념
    - 모든 프로세스에게 동일한 최대 실행 허용 시간 (타임 퀀텀 혹은 타임 슬라이스)를 부여하고, 그 시간만큼씩 공평하게 조금씩 CPU를 보냄 <- 선점형
  - 분석
    - 타임 퀀텀에 따른 문맥 교환 Context Switching)
    - 부담 및 평균대기 시간

- 다단계 큐 MQ Multi-Level Queue
  - 개념
    - 모든 프로세스에게 획일적인 스케줄링 전략을 적용하지 않고, 프로세스들을 특성별로 그룹화하여 각각 독립된 정책을 사용
  - 예
    -프로세스를 중요도 등에 따라 크게 그룹화하여 별도의 큐 관리
    - 계산 위주의 프로세스들은 타임 퀀텀을 길게 주고, 우선 순위는 낮게 부여
    - 입출력 위추 프로세서들은 반대로
  - 분석
    - 더욱 정교한 전략을 적용하기 위해 동일 준비 큐 프로세스들 간에는 다른 스케줄링 전략이 적용

- 다단계 피드백 큐 MFQ Multi-level Feedback Queue

---

@0418  

- 병행처리 Concurrent Processing와 경쟁상황Race Condition 
  - 병행처리
    - 하나의 CPU가 여러 개의 프로세스를 조금씩 번갈아 처리
    - 거시적 관점에서 여러 개의 프로세스를 한꺼번에 처리하는 효과
    - 어느 순간에 보면 오직 하나의 프로세스만이 처리되지만, 공유 변수를 접근한다면 경쟁상황이 발생할 수 '있음' = 무조건 발생이 아님 (병렬처리보다는 빈도가 낮음, 섞일 수도 있음)

- 병렬처리 Parallel Processing와 경쟁상황
  - 병렬처리
    - 다수의 CPU가 여러 개의 프로세스를 한꺼번에 처리
    - 어느 순간에 보면 여러 개의 프로세스들이 처리
    - 공유변수를 접근한다면 경쟁상황이 더욱 심하게 발생할 수 '있음' = 무조건 발생이 아님 (근데 병행처리보다는 빈도가 높음, 섞일 수도 있음)

- 임계영역 Critical Section
  - 경쟁상황이 발생되어 처리의 오류를 일으킬 수 있는 부분

- 상호배제
  - 임계 영역에서는 오직 하나의 프로세스만이 진입할 수 이ㅆ도록함
  - 상호배제는 잠금 Looking 장치와 채제 UnLock 장치로 실형

- 프로그램 동기화 Process Synchronization
  - 임계 영역을 설정하고 그리고 그 어 구분에다가 상호배제 잘치를 잘 설치

- 상호배제 절차 (잠금과 해제 장치)의 조건
  - 계속 진행
    - 임계 영역에 진입한 프로세스가 없을 때는 원하는 프로세스가 곧바로 진입할 수 있어야함
  - 항호 배제
    - 임계 영역에 진입한 프로세스가 존재하면 다른 프로세스들의 진입을 불허되어야 함
  - 대기 한정
    - 임계 영역 진입을 원하는 프로세스들은 랜덤하고 공평하게 진입할 수 있는 기회가 주어져야 함

- 상호배제의 구현 방법
  - 순전히 SW로만 구현하는 방법
  - HW의 지원을 받아 구현하는 방법

---

@0420  

- 미완성 SW 상호배제 시도들

- 공통 깃발 체크 방법
  - whilie(flag == 1); flag = 1;
  - 병렬 처리일때 거의 동시에 진입하면 경쟁상황 발생 가능
  - 병행 처리일때 한 프로세스가 대기 이후 flag = 1; 처리 직전, 주도권이 다른 프로세스로 넘어가고, 해당 프로세스에서도 flag = 0; 처리 직전, 주도권이 다른 프로세스에 넘어가면 경쟁상황 발생 가능 (공유 변수가 덮어씌워지는)

- 자기 깃발 표시 방법
  - while(flag[1] == 1); flag[0] = 1;
  - 공통 깃발 체크 방법과 유사
  - flag[0] = 1; while(flag[1] == 1);

- 차례지키기 방법
  - 동시에는 못들어감
  - 근데 자기 차례가 아니면 공회전 하는 경우 +> 계속 진행 X

---

@0504

- Spin Lock 스핀 록 (if then else white, TAS SAWP, 빙글빙글 돈다 - CPU를 쓴다)
  - 앞에서 제시된 SW 및 HW 상호배제 기법들은 모두 바쁜 대기 기반의 잠금장치들임 <- 스핀록
  - 이런 방법들은 때에 따라 CPU 낭비가 심하고 임계 영역에 진입한 프로세스가 비정상적으로 활동하면 파급효과가 큼
  - 따라서 보다 편리하고 보편적인 개념의 잠금장치가 필요 <- 세마포

- 세마포 (빙글빙글 돌지 않고 대기)
  - S 열쇠
  - P(S) 열쇠를 가져가는 연산 (열쇠 -= 1)
  - P(S) 연산 시 열쇠가 없으면 (열쇠 == 0) 대기 -> OS가 처리
  - V(S) 열쇠를 돌려놓는 연산 (열쇠 += 1)

- 이진 세마포와 카운팅 세마포
  - 이진 세마포 : 주로 상호배재 용으로, 박자 맞추기
    - 세마포 변수 S를 0 or 1로 초기화하고 0 or 1 이외의 값을 사용치 않는 경우
    - 1로 초기화 시 상호 배재, 0으로 초기화 시 보조동기화용으로 사용됨
      - While(1) P(S) ... (V), V(S) P(S), V(S) 이후 기다렸다가 P(S) 하는
  - 카운팅 세마포 : 박자 맞추기, 리소스 카운팅
    - 기능은 똑같은 데 1 이상의 값을 사용하는
    - S를 Buffer 개수로 생각, 가져갈 때 P(S)
    - 왜 S -= 1 일반 연산 안씀 ? -> 이거 자체가 임계 영역

- 생산자-소비자 문제 Producer-Consumer Problem
  - 개념
    - 한 쪽 프로세스는 데이터를 생산하여 전달하고, 다른 한 쪽 프로세스는 전달 받은 데이터를 처리하여 소모함
    - E Empty, F Full, M Mutual Exclusion (상호배재용 = 열쇠?)
    - I.E. Circular Queue 에 한 쪽은 데이터를 넣고, 한 쪽을 데이터를 꺼냄
    - 소비자 (P(F), P(M), F 하나 채움, 0이면 대기, V(M), V(F))
    - 생산자 (P(E), P(M), E 하나 채움, 0이면 대기, V(M), V(E))
    - I.E. 박자 맞추기
    - 소비자 While P(S) Process(Data)
    - 생산자 While GetData() V(S)

- Dining Philosophers Problem 식사하는 철학자들 문제
  - 개념
    - 잠금 (세마포)이 해재디기를 영원히 기다리는 상황, 즉, 교착 상태를 살표보는 상징적 문제

- 모니터의 개념
  - 프로그래밍 언어 수준에서 제공되는 고수준 상호배재 장치
    - 함수(서브루틴, 메소드) 형태로 구분된 임계 영역들의 모임
    - 모니터 내에서는 오로지 하나의 프로세스만이 진입 가능
    - 모니터는 고유의 식별 이름을 가짐
    - 세마포의 잘못된 사용에 따른 오류 가능성을 개선
    - @ 알잘딱으로 한 놈만 들어가도록 감시

- 모니터의 내부(조건) 큐
  - 모니텅 진입한 프로세스가 시간이나 자원을 기다리기 위해 잠시 실행을 유보해야 하는 상황
  - 해당 프로세스는 모니터 잠금 장치를 해제하고 자신은 내부 큐에서 대기
  - 다른 ㄹ프로세스가 모니터에 진입하여 처리르 마치고 나가면서, 필요한 경우 내부 큐에 대기중인 프로세스에게 잠금을 인계 <- 대기 중이던 프로세스가 모니터 내에서 실행을 제개

- 자바 모니터
  - 자바는 객체 단위로 모니터를 형성
  - 해당 모니터에는 synchronized 메소드들만 포함함

@0509

- 교착 상태 Deadlocks
  - 고장난 좌물쇠 -> 나가지도 못하고 나오지도 못함
  - 진퇴양난 -> 영원히 기다리는 상황
  - 주요 원인 : 고장이나 기타 이유로 인한 자원의 부족

- 컴퓨터 자원의 유형
  - HW 자원과 SW 자원
  - 선점 가능한 자원과 선점 불가능 자원
  - 공유 가능 자원과 배타적 사용 자원

- 컴퓨터의 자원 관리 모델
  - 요청 -> 사용 -> 반납 (묵시적, 명시적)
    - 프로세스들은 OS에게 필요한 자원을 요청
    - 지원 요청은 시스템 콜을 사용하여 이루어짐
    - 유닉스/리눅스의 대표적인 자원 요청 시스템 콜은 open(), 자원 반납 시스템 콜은 close()

- 교착 상태의 필요조건
  - 자원의 배타적 사용 Mutual Exclusion
  - 자원의 점유 대기 Hole & Wait
    - 자원의 부분 할당 Partial Allocation
  - 자원 비선점 No Preemption
  - 자원에 대한 환형 대기 Circular Wait
    - 자원 할당 그래프 RAH Resource Allocation Graph로 판별 가능

- 교착 상태 대응 방안
  - 교착 상태 예방 Prevention
    - 교착 상태의 필요조건 중 하나가 성립하지 않는 할당정책 도입
  - 교착 상태 회피 Avoidance
    - 자원을 할당하면서 교착 상태 발생 가능성이 있으면 추가 할당 보류
  - 교착 상태 탐지 및 복구 Detection & Recovery
  - 교착 상태 방치 Don't Care

@0511  

- 교착 상태 예방 Prevention
  - 교착 상태의 필요조건 중 하나가 성립하지 않는 할당정책 도입
  - 자원의 배타적 사용 조건 제거
    - 컴퓨터 자원의  대부분은 배타적으로 사용되어야함, 도입 불가
  - 자원의 점유 대기 조건 제거
    - 사용할 자원 전체를 한꺼번에 할당할 수 있을 때까지 기다림
    - 여러 종류의 자원이 필요한 프로세스의 기아 상태 가능성
    - 자원을 미리 확보함으로써 활둉도 저하, 도입 곤란
  - 자원의 비선점 조건 제거
    - 자원이 부족하면 이지 점유 중인 자원을 강제 회수
    - 롤백 Rollback, 등 큰 비용 동반, 도입 곤란
  - 자원에 대한 환형 대기 조건 제거
    - 모든 자원에 일련 번호를 부여하고, 프로세스에게 자원을 할당할 때는자원의 번호 순서대로만 할당, 환형 대기 조건 발생하지 않음

- 교착 상태 회피 Avoidance
  - 자원을 할당하면서 교착 상태 발생 가능성이 있으면 추가 할당 보류
  - Safe 상태와 Unsafe 상태
    - Safe State
      - 자원 할당이 이루어지더라도 교착 상태가 결코 일어나지 않는 상태
      - 현재 남은 자원이 부족하더라도 점유 중인 프로세스 종료로 자원이 반납되어 모든자원 할당 요구를 만족-하는 시나리오가 존재하면
    - Unsafe State
      - 자원 할당이 이루어진 후, 이후의 모든 자원 할당을 만족시킬 시나리오가 존재하지 않는 경우
  - 자원 할당 그래프 예약 간선, 안전 상태 판별, 교착 상테 회피
    - 자원 할당 그래프의 예약 간선
      - 현재요청된 자원을 할당 햇다는 가정 하의 자원 할당 그래프
      - 예약 간선이 포함된 자원 할당 그래프로부터 안정 상태 여부 판별
      - 안전 상태가 아니면 자원 요청 보류
  - Dijstra의 은행가 알고리즘 Banker's Algorithm
    - 개념
      - 자원에 대한 잠재 수요 및 재고 현황으로부터 안전 상태 식별

- 교착 상태 탐지 및 복구 Detection & Recovery (주기적으로, 가끔)
  - 자원 할당 그래프로부터 안전 상태 여부 판별
    - 점유 대기 현상 (환형 대기, 사이클, Cycle) 이 존재하는지 조사
    - 사이클이 존재한다고 하여 반드시 교착 상태는 아님
  - 사이클 탐색 알고리즘
  - 교착상태 복구
    - 교착 상태를 복구 (해제)하기 위해서는 자원 강제 회수가 불가피
      - 프로세스 단위의 자원 회수
        - 희생 Victim 프로세스를 선정하고, 그 프로세스의 점유 자원 전체를 회수
        - 자원이 부족하면 계속해서 희생 프로세스를 선정하여 회수
        - 자원을 회수 당한 프로세스는 강제 종료 (Roolback)
      - 개별 자원 단위의 회수
        - 희생 프로세스가 점유하고 있는 자원 중 일부만 회수
        - 자원의 일부를 회수당한 프로세스는 후퇴하여 재실행 Rollback

- 교착 상태 방치 Don't Care
  - 교착 상태 예빵, 회피, 탐지 및 복구는 심각한 부담 (성능 저하)를 동반
    - OS는 교착 상태와 관련하여 어떠한 활동도 하지 않음
    - 교착 상태에 관계되어 실행이 중단된 프로세스들은 사용자가 인식하고 처리
    - 대부분의 사용 OS에서 채택

- 메모리 관리 개념

- 메모리 할당 및 회수가 이루어지는 시기
  - 디스크의 프로그램이 메모리에 적재되어 생성될 때 <- 첫 할당
  - 프로세스가 종료되었을 때, 회수
  - 프로세스가 메모리르 추가 요청할 때, 추가 할당
  - 프로세스의 실행을 잠시 보류하고 디스크로 옮길때, 회수
  - 디스크의 보류되었던 프로세스를 다시 실행 재개할 때, 재할당

- 할당 메모리 위치
  - 메모리 할당은 반드시 비어있는 곳에 이루어짐
  - 재 할당의 걍우 꼭 동일장소에 이루어져야 할 수도 있고, 다른 빈 공간에 이루어질 수도 있음

- 메모리 관리의 필요성
  - 위와 같이 메모리는 할당과 회수가 역동적으로 이루어지므로 어느곳이 비어있는지 어느 프로세스에게 어디에 어느만큼의 메모리가 할당되었는지에 대한 관리가 필요함

- 메모리 관리 전략(방법)의 분류
  - ~

- 전체 적재와 일부 적재, 그리고 가상 메모리
  - 전체 적재
    - 프로세스를 실행하기 위해 프로세스 이미지 (Text,Data,Stack등) 전체를 적재
    - 가장 기본적이고 이해가 쉬운ㅇ 전략
    - 실행중인 프로세스들 크기의 총합은 컴퓨터 메모리(주기억장치) 용량 초과 불가
      - 다중 프로그래밍 정도 Degree of Multiprogramming 가 낮아질 수 밖에 없음
  - 일부 적재
    - 프로세스 이미지의 필요한 일부만 적재하여 실행
    - 복잡하고 기교스런 관리 기법이 요구됨
    - 실행 중인 프로세스들 크기의 총합이 메모리 용량을 훨씬 초과할 수 있음
      - 가상 메모리 Virtual Memory
      - 다중 프로그래밍 정도를 높일 수 있음
  - 연속 ~
  - 논리 주소와 물리주소 Logical & Physical Address
