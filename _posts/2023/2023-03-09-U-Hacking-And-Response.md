---
title: "⛏️ 해킹과 대응 기술 과목"
date: 2023-03-09. 15:01
last_modified_at: 2023-03-14. 10:15
categories: ⛏️Memo
---

VMWare 환경에서 Kali-1 Kali-2, 두 개 혹은 하나  
Windows XP 7 업데이트 안된 환경 설치  

XSS CSRP  
XSS SSRF  
CSS XSS  

교재 251 337  
실상이 교재 내용과 다를 수 있음 => 검색  
그 내용을 보고서에  

수업 참여 보고서 - A4 필기구  
9 ~ 12번  

실습 결과 보고서  
3 ~ 5번  
최종공격화면=실습최종결과화면  

---

### 블록암호운영모드

---

- 질문
  - 다음은 무엇을 설명한 것인가?
    - 각각의 평문 블록은 암호화되기 전에 이전 암호문 블록과 XOR 연산한다.  
    - 첫 블록의 경우 이전 암호문 블록이 존재하지 않기 때문에 IV (Initialization Vector)가 사용된다.  
    - 암호화 할 때 이전 블록 암호화 결과에 의존하기 때문에 병렬화가 불가능하지만, 복호화의 경우 각 블록을 복호화한 다음 이전 암호화 블록과 XOR 연산하여 복구할 수 있기 때문에 병렬화가 가능하다.  
  - 다음은 무엇을 설명한 것인가?  
    - Ci = Ek (Pi + Ci-1), C0 = IV (+ : XOR ftn, Ci : i번째 암호문, Pi : i번째 평문, IV:초기벡터, Ek:암호화, Dk:복호화)  
    - Pi = Dk(Ci) + Ci-1, C0 = IV  

- 암호화/복호화 단계별 과정  
- 암호화/복호화 과정에서 병렬처리가 가능한가?  
  - 근거  
- 복호화할 때 왜곡된 비트 정보가 삽입된다면  
- 재전송 공격이 가능한가?
  - 근거

---

- Block Cipher Mode of Operation
  - ECB Electronic CodeBook
    - 평문 블록을 암호화한 것을 그대로 암호블록으로 사용한다
    - 마지막 블록에 패딩이 필요하다
    - 복호화 알고리즘 필요
    - *평문 블록의 패턴이 암호 블록에 그대로 나타난다. 반복 (재전송) 공격에 취약하다
    - *한 개의 블록만 해독되면 나머지 블록도 해독이 되는 단점이 있다 (Brute-Force Attack, Dictionary Attack)
    - 평문 블록의 순서를 바꾸어 공격 가능하다.
    - 병렬 처리가 가능하다.
  - **CBC Cipher-Block Chaining
    - 암호화 알고리즘의 결과를 평문 블록과 XOR하고 나서 암호화를 수행한다.
    - 각 암호문 블록은 이전 평문 블록들의 영향을 받게 된다.
    - *처음 평문 블록을 위해 초기벡터 Initialization Vector가 존재한다  
    - 평문의 마지막 블록에 패딩이 필요하다 (패딩 오라클 공격 가능)
    - *평문에서 1비트의 오류가 생기면 오류가 전파된다
    - 평문의 패턴이 암호문에 나타나지 않는다
    - SSL/TLS에 사용된다
    - 복호화에서 병렬처리가 가능하다
    - 복호화 알고리즘이 필요하다
    - IPSec, AES-CBC 등에서 사용
  - CFB Cipher FeedBack
    - 1단계 앞의 암호문 블록을 암호 알고리즘의 입력으로 사용
    - IV 필요
    - 패딩 불필요
    - *재전송 공격이 가능
    - 복호화 알고리즘이 필요없다
    - CBC모드와 마찬가지로 암호화는 순차적이고, 복호화에서 병렬 처리를 할 수 있다.
  - OFB Outout FeedBack
    - IV 필요
    - 패딩 불필요
    - 암호화/복호화 전에 IV로 사전 준비 가능
    - 복호화 알고리즘이 필요 없다
    - 암호화 함수는 키 생성에만 사용되며, 암호화/복호화 방법이 동일하여 암호문을 한 번 더 암호화하면 평문이 나올 수 있다.
    - 병렬 처리를 할 수 없다.
  - *CTR CounTeR
    - 1씩 증가하는 카운터를 암호화하여 키 스트림을 만드는 스트림 암호
    - *카운터의 초기값은 난수로 만드는 비표 Nonce와 1식 증가하는 블록 번호로 이루어져 있다
    - 오류의 확산이 없다
    - 병렬 처리가 가능하다
    - 패딩이 필요 없다
  - CTS, GCM  
    - GCM Galois Counter Mode  
    - CCM Counter with CBC-MAC  
    - CTS Ciphertext Stealing  
    - XTS mode is similar to CBC-CTS in operation  

---

| | FCB | *CBC | CFB | OFB | CTR |
| 초기화 벡터 | X | O | O | O | - |
| 병렬 처리 | 암호화/복호화 | 복호화 | 복호화 | X | 암호화/복호화 |
| 패딩 | O | O | X | X | X |
| 데이터 형태 | Block | Block | Stream | Stream | Stream |
| 특성(기능) | 간단하며, 패턴이 반복된다. 재전송, 패딩오라클 공격이 가능하다. (해커)암호문 블록의 순서를 뒤섞거나, 삭제/복제 한다. | 암호문 블록이 파손되면 2개의 평문 블록에 영향을 준다. 패딩오라클, 초기화 벡터 공격이 가능하다. | 재전송 공격이 가능하다. 초기화 벡터 공격이 가능하다. | 비트 단위의 오염된 암호문에 대응되는 평문 비트에만 오류가 발생하다. | 카운트를 이용한다 (비트, 블록 번호). 1비트가 오염된 암호문에 대응되는 평문 블록의 1비트에 영향을 주고, 오류 전파는 없다. |
| 적용분야 | | AES-CBC, IPSec, Kerberos V5, SSL/TLS | | | AES-CTR |
| | | | 비동기 | 동기 | 동기 |

---

P1 평문 (n비트 블록1) (64, 128, 256, ...)  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
C1 암호문 (n비트 블록1)  

C1 암호문 (n비트 블록1)  
|  
Key -> Block Cipher Decryption  
|  
P1 평문 (n비트 블록1) (64, 128, 256, ...)  

- ECB 운영모드 (Electronic CodeBook)  
  - #문제가 많다, 사용을 안한다  
  - 짧은 메시지에 적합하며, 오류 전파는 없다
  - 마지막 블록에 패딩이 필요할 수 있따
  - *블록간 독립성이며, 발생하는 오류가 다른 블록에 영향을 주지 않는다.  
  - 기밀성 낮고, 재전송 공격에 취약하며, 암호화/복호화가 병렬적으로 수행된다.
  - 평문의 블록 패턴과 암호문의 블록 패턴이 동일하게 유지된다.

---

P1 평문 (n비트 블록1) (64, 128, 256, ...)  
|  
X <- (IV 초기벡터) = ㄱ  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
X -> = ㄴ  
|  
C1 암호문 (n비트 블록1) (#손상될 경우)  

P2 평문 (n비트 블록2) (64, 128, 256, ...)  
|  
X<- ㄴ  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
X -> = ㄷ  
|  
C2 암호문 (n비트 블록2)  

- CBC Cipher Block Chaining  
  - #문제 나오면 CBC가 답인 경우가 많다! 그만큼 경쟁력이 있다는 것  
  - 각각의 암호 블럭이 영향을 준다. 블록간의 연관성이 존재한다.  
  - *암호화할 때 평문에 손상이 있다면 다음 단계로 파급된다. 복호화할 때도 동일한 효과가 발생한다.  
  - 보안성이 높고, 초기값이 필요하다.  
  - MAC으로 블록을 검사하고, 마지막 블록의 전부 혹은 일부를 MAC으로 사용한다.  

- 평문에서 손상이 발생한다면  
  - 암호화 과정에서 이상한 (다른) 암호가 나온다  
- 암호문이 손상된다면  
  - 복호화 과정에서 이상한 (다른) 평문이 나온다  
  - 그 다음 복호화 단계에도 영향을 준다 (현재 암호가 다음 복호화 단계에서 키로 쓰이니까)  
  - 그 다음 복호화 단계에도 영향을 줄까? ㄴㄴ  

---

IV (초기 벡터) - Random  
n비트 Shift 레지스터 (64, 128, 256, ...)  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
n비트 암호문  
암호문에서 일부 비트만 (r) 선택하여 키 k1로 사용한다. i.e. 8Bit  
|  
X<- r비트 평문 P1  
n비트 암호문 좌측에서 r비트를 선택하여 암호키 k1으로 사용한다  
|  
r비트 암호문 C1  

| C1이 r비트 왼쪽으로 Shifting  
n비트 Shift 레지스터 (64, 128, 256, ...)  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
n비트 암호문  
암호문에서 일부 비트만 (r) 선택하여 키 k2로 사용한다. i.e. 8Bit  
|  
X<- r비트 평문 P1  
n비트 암호문 좌측에서 r비트를 선택하여 암호키 k2으로 사용한다  
|  
r비트 암호문 C2  

- CFB Cipher Feedback  
  - 키 스트림을 이용한다  
  - 오류 전파가 있다  
  - 데이터 처리효율이 낮다. n>r (8 or 16 Bit, 주로 8비트 쓴다고 함)  
  - (암호문 C1이 손상된 경우) P1과 P2 복호화 까지 영향을 미친다. 그러나 암호문 C2에는 무영향이므로, P3를 복호화 할 때 영향을 미치지 않는다.  
  - 암호화/복호화 과정에 동일한 알고리즘을 사용한다  

- 평문에서 손상이 발생한다면  
  - 암호화 과정에서 이상한 (다른) 암호가 나온다  
- 암호문이 손상된다면  
  - 복호화 과정에서 이상한 (다른) 평문이 나온다  
  - 그 다음 복호화 단계에도 영향을 준다 (현재 암호가 다음 복호화 단계에서 Shift 됨)  
  - 그 다음 복호화 단계에도 영향을 줄까? ㄴㄴ  

---

IV (초기 벡터) - Random  
n비트 Shift 레지스터 (64, 128, 256, ...)  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
n비트 암호문  
암호문에서 일부 비트만 (r) 선택하여 키 k1로 사용한다. i.e. 8Bit  
|  
X<- r비트 평문 P1  
n비트 암호문 좌측에서 r비트를 선택하여 암호키 k1으로 사용한다  
|  
r비트 암호문 C1  

| C1이 r비트 왼쪽으로 Shifting  
n비트 Shift 레지스터 (64, 128, 256, ...)  
|  
Key -> Block Cipher Encryption (DES, AES, SEED, ...)  
|  
n비트 암호문  
암호문에서 일부 비트만 (r) 선택하여 키 k2로 사용한다. i.e. 8Bit  
|  
X<- r비트 평문 P1  
n비트 암호문 좌측에서 r비트를 선택하여 암호키 k2으로 사용한다  
|  
r비트 암호문 C2  

- OFB Output FeedBack  
  - CBC, CFB 오류 전파를 제거한다  

- 평문에서 손상이 발생한다면  
  - 암호화 과정에서 이상한 (다른) 암호가 나온다  
- 암호문이 손상된다면  
  - 복호화 과정에서 이상한 (다른) 평문이 나온다  
  - 그 다음 복호화 단계에 영향을 주지 않는다  
    - 현 단계 암호와는 상관없는, Key 값이 다음 복호화 단계에서 Shift 됨  

---

- CTR (CounTeR)  
  - 1씩 증가해가는 카운터를 암호화해서 키스트림을 만들어 내는 스트림 암호이다.  
