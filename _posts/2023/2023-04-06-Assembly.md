---
title: "⛏️ Assembly"
date: 2023-04-06. 11:16
last_modified_at: 2023-05-03. 14:46
categories: ⛏️Memo
---

[https://coding-factory.tistory.com/651](https://coding-factory.tistory.com/651)  
[https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=ndb796&logNo=221054682271](https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=ndb796&logNo=221054682271)  
[http://yuchi.duckdns.org/xe/Programming_QA/5934](http://yuchi.duckdns.org/xe/Programming_QA/5934)  
[http://yuchi.duckdns.org/xe/Programming_QA/5950](http://yuchi.duckdns.org/xe/Programming_QA/5950)  
[https://sunrinjuntae.tistory.com/24](https://sunrinjuntae.tistory.com/24)  
[https://araikuma.tistory.com/600](https://araikuma.tistory.com/600)  
[https://nan491.tistory.com/entry/%EC%8A%A4%ED%83%9DStack-PUSH-POP](https://nan491.tistory.com/entry/%EC%8A%A4%ED%83%9DStack-PUSH-POP)  

어셈블리  
가변인자 함수를 직접 만들거나, C/C++문법을 할 수 없는 일들을 해야할 때  
고급 언어로 할 수 없는 일, MMX나 SSE 등 특수한 기능  

기계어와 어셈이 거의 같다  
CPU에 직접 지시할 명령어의 집합을 만드는 것  
= 기계어의 제약 사항은 어셈블리에 모두 적용된다  

같은 명령어도 CPU 마다 기계어가 다르다  
Intel x86 계열의 CPU용 어셈블리 & 기계어는 다른 벤더의 CPU의 그것과 호환되지 않는다.  
(AMD나 Cyrix CPU는 원래 인텔의 호환칩, 모토롤라의 x68계열이 대표적인 비 호환칩)  
같은 CPU라도 버전에 따라 다른 호환 여부가 달리지는 경우도  
=> 기계어는 CPU 종속적, CPU가 달라지면 새로 프로그래밍 언어를 배워야..  
=> High-Level 언어의 등장  

어셈블러, 어셈블리 -> 기계어로 바꿔주는 어셈블  
컴파일러, 하이레벨 -> 기계어, 어셈블리로 바꿔주는 컴파일  
VM방식, 하이레벨 -> VM(HW 혹은 SW 시뮬)을 설정해서 그 머신용의 기계어 코드로 컴파일 (Like 컴파일러/컴파일)  
I.E. JAVA, PC에 띄워진 SW인 JVM으로 돌아감  

UNIX OS가 C로 쓰인 이후 OS는 거의 대부분 C로 쓰여졌다.  
물론 HW를 직접 다뤄야 하는 부분들이나 속도에 매우 민감한 부분은 어셈블리로 쓰여진다.  
Windows, Unix, Linux 등 익히 알려진 OS들도 대부분의 C와 일부 어셈블리로 쓰여졌다.  

---

GUI (Graphic User Interface)  
vs  
CUI (Console User Interface)  

Dos (Disk Operating System)  
IBM PC가 처음 보급될때 끼워팔았던 OS다.  
Windows 98까지만해도 새까만 화면에 프롬프트 하나 뜨는 도스 부팅이 있었다.  
Windows 2000이나 XP 이후 도스부팅은 불가능  
OS 뜨고나면 Command Prompt창을 띄울 수 있는데, 엄연히 NT커널 하에서 돌아가는 디자인만 도스창 같은 UI(User Interface)  
CUI프로그램의 대표적인 예는 각종 온라인 게임의 서버 프로그램  

---

- Preprocessor (전처리기)
  - #include 같이 앞에 # 붙는 것들
  - 기능 모아둔 라이브러리 \*.lib (\*.dll도 사용하지만 컴파일할땐 \*.lib)
  - 라이브러리 가져다 쓸 수 있게 선언해둔 것이 헤더 파일 \*.h
  - 헤더 파일을 쓸 수 있게 #include 지시어를 사용한다.

- 변수
  - 데이터를 담을 수 있는 일정 단위의 레지스터나 메모리

- 포인터
  - 메모리의 주소를 다루는데 사용하는 데이터 타입
  - 당연한 얘기지만 32비트 컴퓨터에서 메모리 주소의 범위는 0부터 2의 32승(4294967295)까지다.
  - 4바이트 부호없는 정수형과 다른점
    - 1. 컴파일러에 의해 타입 체크가 이루어짐
    - 2. 컴파일러에 의해 몇 가지 산술 연산 제한
    - 3. ++, --, 해당하는 포인터가 가리키는 데이터 타입의 사이즈 만큼

exe 파일 (pe파일의 한 종류) pe헤더에 main()함수가 위치하고 있는 어드레스의 상대번지가 코드 엔트리 포인트로 기록된다.  
exe가 로드되고 실행되면 이 주소를 읽어 main()함수부터 실행  

- 구조체
  - 안에 포함되는 변수(데이타 타입, 구조체 포함)들은 메모리 위에 연속적으로 존재

- 배열
  - 구조체 내의 필드(변수)들의 사이즈는 불규칙하지만
  - 배열 한칸 한칸의 사이즈는 모두 동일하다.
  - 숫자로 정확하게 찾아낼 수 있는 것이다. 인덱스 * 한칸 사이즈

```c

int a = 0;

if (a) a = 0;
else a = 1;

```

```c

int a = 0;

__asm
{
        mov        eax,dword ptr[a]
        cmp         eax,0
        jz        lb_set_a1

; ; ; ;
lb_set_a0:
        xor        eax,eax
        mov        dword ptr[a],eax

; ; ; ;
lb_set_a1:
        inc        eax
        mov        dword ptr[a],eax
}

```

인라인 어셈블리  
eax에 a값 읽어온다. (비교하기 위해)  
cmp : 0과 비교한다.  
jz는 이전의 산술연산의 결과가 0이라면 지정된 주소로 점프하는 명령이다.  
비교라는건 엄밀히 말해서 뺄셈, 뺀 결과 == 0 ? 같은 것 : 다른 것  
따라서 cmp 결과 zero flag 레지스터가 0 or 0 아닌 값  
보는 바와 같이 비교한 결과에 따라 각각 다른 코드로 ‘점프’  
문법상 {}로 묶어 표현하지만 실제로는 jmp, 즉 C/C++문법으로는 goto지시어를 포함하고 있는 것  

반복문은 내부적으로 if를 포함하고 있다.  
더 정확히는 어셈블리의 cmp명령을 포함하고 있다.  
cmp대신 loop명령을 사용할수도 있다.  

```C

int i = 0, s = 0;

lb_loop:
        if (i >= 100)
           goto lb_exit_loop;
        s += i;
        I++;
        goto lb_loop;

lb_exit_loop:

```

이와같다.

인라인 어셈블리로 바꿔보면..  

```C

int s = 0;

__asm
{
        xor                ecx,ecx
        xor                edx,edx

lb_loop:
        inc                ecx
        add                edx,ecx

        cmp                ecx,100
        jnz                lb_loop

        mov                dword ptr[s],edx
}

```

---

인자 Argument 전달  
인자의 전달은 일반적으로 스택  
4바이트 이하는 스택에 푸쉬, 초과는 mov등으로 카피하고 함수에 진입하여 스택으로부터 pop하거나 mov등으로 카피된 데이타를 억세스 하게 된다.  
참고로 C에서 포인터를 많이 쓰는 이유가 여기에 있다.  
덩치큰 메모리 블럭을 바로 인자로 전달하려 하면 몽땅 스택에 카피해야 하므로 함수 진입시에 속도가 떨어지게 된다.  
그래서 보통 포인터로 전달한다.  
포인터는 4바이트짜리이므로 push 한번이면 되니까.  

함수 안에서 선언해서 사용한 지역변수는 함수를 벗어날때 소멸한다.  
메카니즘으로 설명하자면 원래 함수에 진입할때는 그 함수에서 사용하는 지역변수의 총 사이즈를 계산해서 그만큼 스택 공간을 확보하게 된다.  
단순히 스택포인터(esp레지스터)를 사이즈만큼 빼주는 것이다.  
스택은 미리 확보되어있는 메모리니까.  
그리고 함수를 나갈때 스텍포인터를 원래대로 돌린다.  
스택포인터가 원래대로 되돌려지고나면 스택을 사용하는 다른 코드들에 의해서 방금까지 사용하던 스택 메모리 영역은 overwrite될 수 있다.  
그러니까 정확히는 소멸한다기보다는, 함수에서 벗어난 후에는 지역변수에 기입된 내용이 멀쩡하다고 보장할 수 없는 것이다.

디버그 인터럽트(Debug Interrupt)  
CPU의 작동 흐름을 간섭하는 일종의 긴급 신호  
HW 인터럽트, 타이머칩/타이머 인터럽트, 주변장치의 IO/HW 인터럽트  
SW 인터럽트, CPU가 연산도중 발생시키는 인터럽트  
0으로 나누기, 금지된 메모리 영역을 억세스 -> 인터럽트 발생  
게임 중 잘못된 연산오류~를 본다면 이와같은 SW 인터럽트로 인해 APP이 크래쉬  
이러한 SW 인터럽트는 Exception, SW적으로 프로그래머가 발생시킬 수 있다. __asm int 3  

버그 유형과 원인, 대처 요령  
프로그램이 크래쉬하게 만드는 버그:

-commit되지 않은 메모리 어드레스 억세스
정상적인 OS하에 돌아가는 모든 소프트웨어는 OS로부터 메모리를 할당받아야만 쓸 수 있다.  
스택영역도 물론 프로세스 초기화시에 할당받은 영역이다.  
보통 reserve와 commit이라는 과정을 거쳐 메모리를 사용할 수 있게 되는데 commit이 이루어져야 할당받은 어드레스가 실제 물리 메모리에 맵핑된다.  
만약 commit되지 않은, 그러니까 물리 메모리에 맵핑 되지 않은 영역을 억세스 하려고 하면 CPU는 익셉션을 발생시킨다.  
또한 0번지는 사용이 불가하도록 OS가 설정해놓았으므로 commit/억세스 불가  

-Heap 크래쉬
HEAP : 메모리를 미리 덩어리로 받아놓고 끊어쓰는 메모리 풀  
I.E. malloc()/free(), new/delete  
힙의 특성상 할당받은 사이즈를 넘겨서 덮어쓰게 되면 다른 블럭이 깨짐  
힙크래쉬가 발생하면 구현하기 나름이지만 눈치채지 못하게 조용하게 돌아갈수도 있고 어플리케이션이 크래쉬할수도 있다. 또는 파일이 열리지 않기도 한다.  

---

```Assembly

; 문법 { Intel (주로 쓰임), AT&T }
; 명령어 수행 방식 (ADD EAX EBX, Intel은 EAX += EBX, AT&T는 EBX += EAX)
; 값/숫자 표기 방식 (Intel은 16진수 Prefix h와 2진수 Prefix b, AT&T는 Prefix $)
; 레지스터 표기 방식 (Intel은 그대로, AT&T는 Prefix %)

; 한 줄 주석  

COMMENT !
여러 줄 주석
느낌표 대신 @, #, $, % 등도 가능
!

COMMENT !

C 인라인 어셈블리
__asm
{
    ;
}

!

; 대소문자 상관 없음

; NOP, 0x90
; 아무 작업도 안함, 클럭 소모, 1Byte의 빈 공간 차지

; MOV A B
; MOVE, A에 B 값 넣기, 연산 포함 불가능

; LEA A B
; Load Effective Address, 연산 포함 가능
; LEA EAX, [EAX + 1000]

; INC
; Increase 피 연산자에 1을 더하기
; 연산 결과에 따라 Zero Flag ZF, Overflow Flag OF 세트 가능

; JMP A
; 특정 위치 A로 점프
; JA, JB, JE 등
; ---
; 004013D4         EB 01
; 004013D6         CC
; ---
; 215:          jmp     label_1
; 216:          int     3
; 217:  label_1:
; ---
; jmp == 0xEB 0x01  
; 어셈블리에서 JMP는 한개지만 실제로 기계어코드로 바뀔때는 옆의 오퍼랜드(위에서는 0x01)에 따라 각각 다른 명령으로 대치된다.  
; 이 명령은 1바이트 건너뛰라는 뜻이 되겠다.

; CALL
; 함수를 호출했다가 다시 원래 위치로 돌아올 때
; JMP와 다른 점은 실행한 뒤에 끝나면 RET에 저장하고 다시 원래 상태로 돌아옴

! RET
; 현재 함수가 끝난 뒤에 돌아갈 주소를 지정하기 위해 사용

; PUSH
; 스택에 값 넣기

; POP
; 스택에 있는 값 빼내기

; INT 3, 0xCC
; 디버그 인터럽트

; LEAVE
; 현재까지의 메모리 스택 비우고, EBP를 자신이 호출한 메모리로 채움
; 실행중인 함수를 종료하기 위해 정리하는 작업에 사용

; 문법
; 함수 리턴 값은 RAX, EAX에 저장
; 목적지는 RDI, 출발지는 RSI
; RBP Base Pointer
; RSP Stack Pointer
; RIP 현재 실행할 코드의 주소

; 시스템 콜

; 레지스터 0 초기화

; MOV AX, 0
; (크기 3~4)

; SUB AX, AX
; XOR AX, AX
; (크기 1~2)

add eax, edx;
; eax와 edx의 내용을 더한다.

; 더한값은 eax 레지스터에 저장된다.

; 레지스터
; CPU 안에 들어있는 고속 메모리, 데이터 이동, 산술 연산 등의 기능

; x86 CPU는 다음과 같은 레지스터들을 가지고 있다.  
; 특수한 몇 개의 레지스터들을 제외하고는 모두 32비트 레지스터이다.  
; EAX, EBX, ECX, EDX는 8비트씩 쪼개서 사용할 수 있다.  
; 이는 그 자체로서 쓸모가 있기도 하지만 과거 8086과 호환성을 유지하기 위함이 크다.  
; 16비트 시절만 해도 레지스터 이름 앞에 E가 붙지는 않았다.  
; 이는 32비트 386부터 생긴 것 인데 32비트로 확장되었다는 뜻이다.  
; R, 64비트

; Stack Pointer, SP/ESP/RSP
; 현재 스택의 위치를 가리키는 레지스터
; 임의로 조작할 수도 있지만 일반적인 프로그램을 짤때는 건드리지 않는 것이 좋다.
; push, pop 명령과 연동된다. push하면 4바이트 감소, pop하면 4바이트 증가한다.
; 스택은 미리 일정 사이즈를 확보해놓고 그 상태에서 사용할때마다 0을 향해서 감소해가는 형태이기 때문에 push했을 때 스택포인터가 감소하는 것이다.
; 메모리 공간에서 Push==할당, pop==해제 라고 생각하면 된다.

; Base Pointer, BP/EBP/RBP
; 일반적으로 함수 진입 시에 스텍 프레임과 함수 안에서 자유롭게 사용하게 될(push, pop) 스택공간과의 경계를 지정하기 위해 사용한다.

; 물론 ebp를 사용하지 않고 바로 esp로 억세스 해도 되지만(실제로 컴파일러가 최적화할땐 그렇게 한다)
; 사람이 짤 때는 엄청나게 헷갈린다.
; 가령 함수에 진입했을 때 첫 번째 인자는 ebp+8의 메모리에 존재하지만 esp 기준으로는 어디가 될지 모른다.
; push, pop할때마다 esp의 값이 바뀌기 때문에 기준점으론 삼을 수가 없는 것이다.

; 인덱스 레지스터
; 인덱스 레지스터는 범용 레지스터들처럼 쪼개서 사용할 수 없다.
; 32비트 그 자체로만 사용할 수 있다.
; 데이터 이동에 관련된 특수한 명령들을 사용할 때 source와 destination 어드레스를 지정하는 등 주소지정에 관련된 특수 기능을 가지고 있기 때문에 인덱스 레지스터라고 한다.

; Source Index SE/ESI/RSI
; 왜 source인고 하니 특수한 데이터 이동 명령 movs 등을 사용할 때 esi에 source 메모리의 어드레스를 넣어야 하기 때문이다.
; 그 밖에는 일반적으로 메모리의 주소를 지칭할 때 이 레지스터를 사용한다.

; Destination DI/EDI/RDI
; ESI와 기본적으로 같고 movs등을 사용할 때 destination 어드레스를 넣어야 한다.

; 범용 레지스터
; 범용 레지스터는 8비트씩 쪼개서 사용할 수 있다.
; EAX의 경우 AL(LOW바이트),AH(HI바이트)로 8비트씩, 이를 합쳐서 AX로16비트씩, 32비트로 억세스 할 때는 EAX가 된다.
; 네 개의 레지스터 모두 같은 규칙을 따른다.
; 기본적으로 산술 연산에 많이 쓰이고 몇 가지 특수한 기능들을 가진다.

; EAX, EDX
; 곱셈 나눗셈을 할 때는 반드시 이 레지스터들을 사용해야 한다.
; 연산의 결과 혹은 소스의 값이 64비트일 때 하위 32비트 = EAX, 상위 32비트 = EDX에 저장된다.
; 인텔계 컴파일러에서는 함수의 리턴값이 eax레지스터를 통해 전달된다.

; EBX
; 기본적인 범용 레지스터의 기능을 가지고 있다.

; ECX
; 카운터 레지스터라고 부른다. loop나 movs등의 명령과 함께 쓰일 경우 카운터로 쓰인다.

; MMX레지스터
; MMX레지스터는 펜티엄 클래식 MMX버전부터 추가되었다.
; 정확히는 물리적으로 존재하는 레지스터가 아니고 FPU 스택을 레지스터처럼 사용한다. MM0부터  MM7 까지 8개가 있다.

; SSE레지스터
; 펜티엄3부터 추가되었다.
; 32비트 float 데이타 4샘플을 동시에 처리할 수 있는 128비트 레지스터이다.
; XMM0부터 XMM7까지 8개가 있다.

; 디버그 레지스터, 플래그 래지스터 같은 특수한 레지스터들 유져모드 프로그래밍에선 쓸 일 없음

```
