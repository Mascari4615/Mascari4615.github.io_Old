---
title: "⛏️ 소프트웨어 공학 - 캡스톤 디자인 과목"
date: 2023-03-09. 14:59
last_modified_at: 2023-04-10. 16:31
categories: ⛏️Memo
---

아.  

교수님께서  
저번 강의 평가가 안좋아서  
멘탈이 나갔다고 하신다  

원래 학점 다 - 주던걸 이제 FM대로 한다고 하신다  

아.  

- 전문적 소프트웨어 개발  
  - 소프트웨어 공학은 무엇인가  
- 소프트웨어 공학 윤리  
  - 소프트웨어 공학에 영향을 미치는 윤리적 이슈에 대한 간단한 소개
- 사례 연구  
  - 책 전반에 걸쳐 사용하는 예제

프로와 아마추어, 돈을 받느냐 안받느냐  
과학과 공학, 이론과 응용  

공학은 사람을 위한?  

교수님께서는 두산 프로 야구팀을 좋아하신다.  
이승엽? 이라는 분이 이번에 감독이 되었다고 하는데  
별로 좋아하시지 않는다고 한다.  

왜 와이  
우리나라의 뛰어난 타자인 것은 분명하나  
성격이 마음에 들지 않는다고 한다.  

왜 와이  
선수 시절 사인을 안해줬다고 한다.  
본능적으로 별로라고 생각하셨다고 한다.  

같은 이유로 류현진 선수도 별로 좋아하시지 않는다고 한다.  

소프트웨어 공학에서,  
소프트웨어는,  
단지 프로그램 (코드) 뿐만 아니라,  
프로그램들과 관련된 기타문서들도 포함한 것을 말한다.  

일반 Generic 제품, 일반 고객 - 오픈 마켓  
모르는 니즈를 고민  
제품 명세서 Specification 개발자가 결정  

맞춤식 Customized 제품, 특정 고객  
주어진 니즈에 맞게
제품 명세서 고객이 결정  

좋은 소프트웨어의 필수적 특성  

- 수용성 Acceptability  
  - 설계 목적에 부합하는 사용자 유형이 수용할 수 있어야
  - 사용자의 이해 가능, 사용 쉬운, 사용자의 기타 도구와 호환
- 확실성 Dependability 과 보안 Security  
  - 신뢰성, 보안, 안전성
  - 고장나더라도 물리적, 경제적 피해를 야기 X
  - 보안을 통해 악의적 사용자가 시스템에 접근하거나 피해를 주지 않도록  
- 효율성 Efficiency  
  - 메모리, 프로세서 사이클과 같은 시스템 자원 낭비해서 사용 X
  - 즉 - 효율성 = 응답성, 처리 시간, 자원 활용
- 유지보수성 Maintainability  
  - 고객들의 변화하는 요구를 충족시킬 수 있도록 진화하도록  
  - 소프트웨어 변경은 필연적 (결함, 환경 변화 적응), 매우 중요
    - I.E. 코로나로 인해, 기존에 있던 학교 동영상 강의 사이트에 실시간 온라인 강의를 추가 / 수강신청이 휴대폰에서도, 그 중에서도 또 여러 기기 기종을 지원하도록  

중요한 이유  
개인/사회가 발전된 소프트웨어 시스템에 더욱 의존  
=> 경제적으로 신속하고 안정적이고 신뢰할 수 있는 시스템을 생산할 필요  

주먹구구식보다 소프트웨어 공학 방법과 기술이 비용이 적게 소모  
대부분의 시스템에서 발생하는 비용이 유지보수  

지난 강의 평가가 교수님의 깊은 트리거가 되신 듯하다  
괜히 불똥이 튄다. 으악  

소프트웨어 프로세스 활동  

명세화 Specification  
개발 Development  
검증 Validation  
진화 Evolution  

소프트웨어 영향을 미치는 문제  

이질성 Heterogeneity  
비즈니스와 사회적 변화  
보안과 신뢰  
규모  

---

- 사례 연구
  - 인슐린 펌프 제어 시스템
  - 환자 정보 시스템
  - 기상 관측기
  - iLearn: 학교용 디지털 학습 환경

UML Unified Modeling Language  

---

HW 고장 곡선  
SW 실패 곡선  

이상적인 곡선과 현실적인 곡선  

---

- 소프트웨어의 특성으로인한 개발의 어려움  
  - 물리적인 형태가 없는 무형의 논리적인 요소
    - 개발 과정에 대해 정확하게 이해하기 어려움
    - 개발 진행 상황을 파악하기도 어려움
  - 최종 산출물이 개발 과정에서 확인되지 않음
    - 오류를 발견해야 할 시기를 놓치거나,
    - 오류에 대한 해결책을 못 찾는 경우가 발생
  - 프로젝트의 지연 및 예산 범위 초과로 인한 프로젝트 실패 가능성이 높음

~

---

과학 : 자연현상 탐구  
공학 : 실제적 문제 해결  

- 공학
  - 의미
    - 실제적 문제 Practical Problem를 해결하거나
    - 실제적인 산출물을 생산해내기 위해
    - 자원과 비용을 효과적으로 활용하면서
    - 과학적 지식을 적용하는 것
  - 공학과 소프트웨어 공학
    - 공학: 업무 분야에서 문제 발생 시, 실무자가 적절한 해답을 찾을 수 있도록 체계적으로 정리된 기술적 지식을 제공
    - 소프트웨어 공학
      - 소프트웨어 개발 기술, 절차 및 도구의 우수한 사례 Best Practice들을 정리하여 소프트웨어 개발 시, 누구나 당면한 문제를 해결할 수 있도록 체계적인 기술적 지식을 제공

---

점진적 -  
점증적 - 증분 단위로 개발  

---

- 폭포수 모델
  - 요구사항이 처음부터 완벽하고 고정된다는 것이 전제
  - 한 단계 한 단계 진행

- 애자일 기법
  - 신속한 개발과 Deliver는 현재 소프트웨어 시스템의 가장 중요한 요구사항 중 하나
    - 비즈니스의 요구사항은 빠르게 변화하고 있으므로 고정된 소프트웨어 요구사항을 생성하는 것은 불가능
    - 소프트웨어는 변화하는 비즈니스 요구를 반영하기 위해 신속하게 변경(진화)되어야 함
  - 계획 주도 개발 (폭포수 모델)은 안정성 중심 시스템과 같은 유형의 시스템에는 필수적이지만 이러한 비즈니스 요구를 만족할 수 없음
  - 1990년대 후반에 등장한 애자일 개발의 목표는 소프트웨어 시스템의 인도 시간을 회기적으로 감소시키는 것

- 애자일 개발
  - 명세화, 설계, 구현 프로세스가 서로 *중첩
  - 시스템을 버전이나 증분의 연속으로 구현하고, 이 때 버전의 명세화와 평가에 이해당사자 Stakeholders 가 참여
  - 새로운 버전의 평가를 위한 인도는 *자주 이루어짐
  - 개발을 지원하기 위한 다양한 도구 (예, 자동화된 테스팅 도구)
  - *코드 작성에 초점을 맞추고 문서 작업은 최소화

65p P3-1  

- 계획 주도 개발과 애자일 개발  
  - 계획 주도 개발 (계획 중심 개발)
    - 소프트웨어 공학에 대한 계획 중심 접근 방식은 각 단계에서 미리 계획한 산출물과 함께 별도의 개발 단계에 기초함
    - 반드시 폭포수 모델일 필요는 없는 점증적 개발이 가능
    - 반복은 각 활동 내에서 이루어짐
  - 애자일 개발
    - 명세화 ~

- 애자일 기법
  - 1980년대와 1990년대의 소프트웨어 설계 방법에서 설계 및 문서화에 수반되는 오버해드에 대한 불만으로 애자일 기법이 탄생
    - 설계보다는 코드에 집중
    - 소프트웨어 개발에 대한 반복적 접근 방식에 기반
    - 동작하는 소프트웨어를 신속하게 인도하고 빠르게 개선하여 변화하는 요구사항을 충족하도록 의도됨
  - 애자일 기법의 목적은 소프트웨어 프로세스의 오버해드를 줄이고(예를 들어 문서화를 제한함으로써) 과도학 재작업 없이 변화하는 요구사항에 신속하게 대응할 수 있음

67p  

- 애자일 기법의 적용
  - 소프트웨어 회사가 중소 규모의 제품을 판매할 목적으로 개발하는 경우
    - 현재 사실상 거의 모든 소프트웨어 제품 및 앱이 애자일 기법을 사용하여 개발됨
  - 개발 프로세스에 참여하겠다는 고객의 명확한 의사가 있고 소프트웨어에 영향을 미치는 외부당사자나 규제가 거의 없는 조직 내의 맞춤형 시스템 개발

- 익스트림 프로그래밍 eXtreme Programming  
  - 1990년대 후반에 개발된 매우 영향력 있는 애자일 기법으로서, 다양한 애자일 개발 기술이 등장
  - 익스트림 프로그래밍 XP은 반복적인 개발에 '극단적인' 접근 방식을 채택
    - 새로운 버전은 하루에 여러 번 제작
    - 증분은 격주마다 고객에게 인도
    - 모든 테스트는 모든 빌드에 대해 실행되어야 하며 빌드는 테스트가 성공적으로 실행되는 경우에만 허용

---

- 애자일 프로젝트 관리
  - SW 프로젝트 관리자의 주된 책임은 SW를 프로젝트 계획 예산 범위 내에서 제때에 인도하도록 관리하는 것이다.
  - 프로젝트 관리에 대한 표준접근법은 계획 중심이다. 관리자들은 어떤 내용이 인도되어야 하는지, 언제 인도되어야 하는지, 누가 프로젝트 산출물 개발에 힘쓸 것인지를 보여주는 프로젝트 계획을 작성한다.
  - 애자일 프로젝트 관리에는 다른 접근 방식이 필요하며, 점증적인 개발 및 애자일 기법에 사용되는 관행에 맞게 조정된다.

- 스크럼
  - 특정 애자일 실무보다는 반복적인 개발 관리에 초점을 맞춘 애자일 기법이다.
  - 3단계
    - 초기 단계는 프로젝트의 일반적인 목표를 설정하고 SW 아키텍처를 설계하는 개요 계획 단계
    - 일련의 스프린트 사이클이 뒤따르며, 각 사이클은 시스템의 증분을 개발
    - 프로젝트 종료 단계는 프로젝트를 마무리하고 시스템 도움말 프레임과 사용자 설명서와 같은 필수적인 문서를 작성하며 프로젝트에서 얻은 교훈을 평가

~

~

- 시스템 모델링
  - 시스템 모델링은 시스템의 추상적 모델을 개발하느 과정이며, 각 모델은 시스템의 다른 뷰나 관점을 제시
  - 시스템 모델링은 이제 거이 항상 UML의 표기법을 기반으로 하는 그래픽 표기법을 사용하여 시스템을 표현하느 것을 의미
  - 시스템 모델링은 분석가가 시스템의 기능을 이해하는데 도움이 되며, 모델은 고객과의 의사소통에 사용

- 기존의 시스템과 개발될 시스템
  - @기존 시스템의 모델은 요구공학 중에 사용되고, 기존 시스템이 무엇을 하고 있으며 장단점을 논의하기 위한 기초로 사용될 수 있는가를 명확히 하는데 도움을 줌. 이러한 것들은 새로운 @시스템에 대한 요구 사항으로 이어짐
  - 새로운 시스템의 모델은 제안된 요구 사항을 요구 공학 중에 다른 시스템 이해당사자들에게 설명하는 데 도움을 주기 위해 사용됨. 엔지니어는 설계안을 논의하고 구현을 위한 시스템을 문서화하기 위해 이 모델을 사용

- 시스템 관점
  - 시스템의 컨텍스트나 환경을 모델링하는 외부 관점
  - 시스템과 환경 사이의 상호 작용을 모델링하는 상호 작용 관점
  - 시스템의 구성이나 시스템에 의해 처리되는 데이터의 구조를 모델링하는 구조 관점
  - 시스템의 동적인 행동을 모델링하는 동작 관점

~

- 그래픽 모델을 사용하는 방법
  - 기존 또는 제안된 시스템에 대한 토론을 자극하고 초점을 맞춤
    - 불완전하고 잘못된 모델이라도 토론을 지원하는 역할이므로 OK
  - 기존 시스템의 문서화
    - 모델은 시스템을 정확하게 나타내야 하지만 완전하지는 않아도 됨
  - 시스템 구현에 이용될 수 있는 상세한 시스템 Description
    - 모델은 정확하고 완전해야 함

- 컨텍스트 모델
  - 시스템이 동작하는 전체 컨텍스트를 설명하는데 사용 - 시스템 경계 밖에 무엇이 있는지 표현
  - 사회적 관계는 시스템 위치 결정에 영향을 미칠 수 있음
  - 아키텍처 모델은 시스템과 다른 시스템과의 관계를 표현

@스테레오 타입  

- 시스템 경계
  - 시스템 경계는 시스템 내부에 무엇이 있고 시스템 외부에 무엇이 있는지 정의하기 위해 설정
    - 개발중인 시스템에 사용되거나 의존하는 다른 시스템을 표현
  - 시스템 경계의 위치는 시스템 요구사항에 지대한 영향을미침
  - 시스템 경계 정의는 정치적 판단
    - 조직의 서로 다른 부분의 영향이나 시스템 경계를 설정하라는 압력에 의해 업무량이 증가/감소할 수 있음

- 프로세스 관점
  - 컨텍스트 모델은 개발 중인 시스템이 그 환경에서 어떻게 사용되는지가 아니라 해당 환경에서의 다른 시스템들을 간단하게 표현
  - 프로세스 모델은 개발 중인 시스템이 보다 광범위한 비즈니스 프로세스에서 어떻게 사용되는지를 표현
  - UML 액티비티 다이어그램을 사용하여 비즈니스 프로세스 모델을 정의

- 상호 작용 모델
  - 사용자 상호작용을 모델링하는 것은 사용자 요구사항을 식별하는 데 도움이 되기 때문에 중요
  - 시스템 간 상호 작용 모델링은 발생할 수 있는 커뮤니케이션 문제를 강조
  - 컴포넌트 상호작용 모델링은 제안된 시스템 구조가 필요한 시스템 성능과 신뢰성을 제공할 가능성이 있는지 여부를 이해하는데 도움이 됨
  - 유스케이스 다이어그램과 시퀸스 다이어그램이 상호작용 모델링에 이용됨

- 유스케이스 모델링
  - 유스케이스는 원래 요구사항 도출 지원을 위해 개발되었고 현재는 UML에 통합됨
  - 각 유스케이스는 시스템과의 외부 상호작용을 포함하는 별개의 작업을 나타냄
  - 유스케이스의 액터는 사람 또는 다른 시스템
  - 유스케이스의 개요는 다이어그램으로 표현하고 보다 상세한 정보는 텍스트 양식을 제공

- 시퀸스 다이어그램 (순차 다이어그램)
  - 시퀸스 다이어그램은 UML의 하나로, 액터와 시스템 내의 객체 사이의 상호작용을 모델링하는 데 사용
  - 시퀸스 다이어그램은 특정 유스케이스 또는 유스케이스 인스턴스 중에 발생하는 상호작용 순서를 표현
  - 포함된 객체와 액터는 다이어그램 상단을 따라 나열되며, 이들로부터 수직으로 점선이 그려짐
  - 객체 간의 상호 작용은 주석이 붙은 화살표로 표현

@ 144p  

@ 시퀀스 다이어그램가 클래스의 연산, 시험?  

- 구조 모델
  - SW의 구조 모델은 시스템을 구성하는 Component와 Component들의 관계로 시스템을 표현
  - 구조 모델은 시스템 설계의 구조를 부여주는 정적 모델 또는 시스템이 실행 중일 때 시스템의 구성을 보여주는 동적 모델
  - 시스템 아키텍처를 노의하고 설계할 때 시스템의 구조 모델을 생성

- 클래스 다이어그램
  - 클래스 다이어그램은 시스템의 클래스와 이러한 클래스 간의 연관성을 보여주는 객체 지향 시스템 모델을 개발할 때 사용
  - 클래스는 시스템 객체에 대한 일반적인 정의
  - 연관 Association 은 클래스들 사이의 어떤 관계가 있음을 나타내는 클래스들 간의 연결 Link
  - SW 공학 프로세스의 초기 단계에서 모델을 개발할 때, 객체는 환자/처방전/의사 등과 같은 실세계의 어떤 것을 표현

- UML 클래스의 연관
  - UML 다이어그램의 각 구성 요소는 소스 코드로 구현될 것

---

0410  

- 아키텍쳐 설계 결정
  - 아키텍쳐 설계는 창조적인 프로세스로 개발되는 시스템의 유형, @아키텍트의 배경과 경험, 시스템의 특정 요구사항에 좌우됨
  - 그러나 다수의 공통적인 결정이 존재하고, 이러한 결정은 시스템의 비기능적인 특성에 영향을 끼침

- 아키텍처 재사용
  - 동일한 도메인의 시스템은 도메인 개념을 반영하는 유사한 아키텍처를 가짐
  - 응용 시스템의 제품 라인 Product Line 이 핵심 아키텍처를 중심으로 구축되고, 특정 고객의 요구사항을 만족하는 변동 부분이 있음
  - 시스템 아키텍처는 하나 이상의 아키텍처 패턴 또는 '스타일' 중 하나를 중심으로 설계
    - 아키텍처의 핵심을 파악하여 상이한 방식으로 인스턴스화할 수 있음

- 아키텍처와 비기능적 요구사항
  - 성능 Performance
    - 중요한 연산을 지역화시켜 통신을 최소화. 단위가 큰 컴포넌트를 사용
  - 보안성 Security
    - 중요한 자산을 내부 계층에 두는 계층 아키텍처를 사용
  - 안전성 Safety
    - 안전성이 중요한 부분을 작은 수의 서브시스템으로 국한시킴
  - 가용성 Availability
    - 여분의 컴포넌트와 결함 내성을 위한 메커니즘을 포함
  - 유지보수성 Maintainability
    - 단위가 작은 대치 가능한 컴포넌트를 사용

- 아키텍처 뷰
  - 시스템 아키텍처를 설계하고 문서화할 때 어떤 뷰 views 이나 관점 Perspectives 이 유용한가?
  - 아키텍처 모델을 기술하는 데 어떤 표기법이 사용되어야 하는가?
  - 각 아키텍처 모델은 시스템에 대한 하나의 뷰 또는 관점만 표현
    - 시스템이 어떻게 모듈로 분해되는지, 런타임 프로세스가 어떻게 상호작용하는지 또는 시스템 컴포넌트가 네트워크 상에서 분산되는 다른 방식을 표현. 설계와 문서에서는 항상 SW 아키텍처에 대한 다중 뷰를 제시할 필요가 있음

- SW의 4+1 뷰 모델
  - 논리적 뷰
  - 프로세스 뷰
  - 개발 뷰
  - 물리적 뷰
  - 유스케이스나 시나리오를 이용하는 것과 관련 +1

- 아키텍처 뷰의 표현
  - 일부 사람들은 통합 모델링 언어 UML가 시스템 아키텍처를 기술하고 문서화하기 위한 적절한 표기법이라고 주장
  - 교재의 저자는 UML이 높은 수준의 시스템 표현에 적합한 추상화를 포함하고 있다고 생각하지 않기 때문에 반대 의견
  - 아키텍처 기술 언어 ADL가 개발되었지만, 널리 이용되지 않음

- 아키텍처 패턴
  - 서로 다른 시스템과 환경에서 시도되고 테스트된 우수한 사례를 정형화하고 추상화한 기술
  - 이전 시스템에서 성공적이었던 시스템 구조 기술
  - 해당 패턴을 언제 사용하기에 적절하고 적절하지 않은지에 대한 정보 포함
  - 패턴의 강점과 약점에 대한 상세한 내용 포함

- MVC Model-View-Controller 모델 뷰 제어기 패턴

- 계층 아키텍처
  - 서브 시스템의 인터페이스를 모델링하는데 이용
  - 각 층이 서비스 집합을 제공하는 계층 집합(추상 머신)으로 시스템을 구성
  - 상이한 계층에 있는 서브 시스템의 점증적 개발을 지원. 계층 인터페이스가 변경될 때, 인접 계층에만 영향을 줌.

- 계층 아키텍처의 장단점
  - 장점
    - 시스템의 점증적인 개발을 지원한다. 한 계층이 개발됨에 따라, 그 계층에 의해 제공되는 서비스들의 일부를 사용자가 이용할 수 있다.
    - 변경 가능하며 이식 가능하다. 계층의 인터페이스가 변경되지 않는 한, 동등한 다른 계층에 의해 대체될 수 있따.
  - 단점
    - 시스템을 구조화하는 것이 어려울 수 있다. 최상위 수준의 사용자가 요구하는 서비스는 그 아래의 여러 계층이 제공하는 서비스에 접근하기 위해 인접 계층을 '뚫고 지나가야' 할 수도 있다. 이런 방식은 시스템의 외부 계층이 바로 그 이전의 계층에 종속되지 않음에 따라 계층 모델을 망가뜨리게 된다.
    - 여러 수준의 명령어 해석이 필요하기 때문에 성능이 문제가 될 수 있다. 최상위 계층으로부터의 서비스 요청은 처리되기 전에 상이한 계층에서 여러 번 해석되어야 한다.

- 계층 아키텍처 패턴

- 범용 계층 아키텍처
  - APP
  - VM
  - OS
  - HW

- 범용 계층 아키텍처
  - User Interface
  - User Interface Management Authentication and Authorization
  - Core Business Logic/App Functionality System Utilities
  - System Support (OS, DB, ETC.)

- OSI 참조 모델 - 계층 모델

- CASE 도구 집합 아키텍처 - 저장소 모델
  - 모든 공유 데이터가 중앙의 DB에 보관되어 있는 모든 서브시스템들이 접근할 수 있따. 공유 DB 에기반을 둔 시스템 모델을 저장소 모델이라고 부른다
  - 각 서브시스템이 자신의 DB를 유지한다. 데이터는 서브시스템 사이에 메시지를 전달하여 상호 교환된다

- 저장소 Repository 패턴

- 저장소 아키텍처 장단점
  - 장점
    - 공유 저장소는 다량의 데이터를 공유하는 효과적인 방식이다
    - 데이터를 생성하는 서브시스템은 다른 시스템들이 이 데이터를 어떻게 사용하는지에 대해 알 필요가 없다
    - 백업, 보안, 접근 제어, 오류로부터의 복구와 같은 활동들은 중앙 집중화된다
    - 합의된 데이터 모델에 적합한 새로운 도구들을 통합하는 것은 간단하다
  - 단점
    - 서브시스템들은 저장소 데이터 모델에 대해 합의를 해야한다
    - 합의된 데이터 모델에 맞춰 다량의 정보가 생성됨에 따라서 진화가 어려울 수도 있다
    - 상이한 서브시스템들은 보안, 복구, 백업 정책에 관해 서로 다른 요구사항을 가질 수도 있다
    - 저장소를 다수의 컴퓨터로 분산시키는 것은 어려울 수 있다.

- Client-Server 아키텍처
  - 데이터와 프로세싱이 일련의 컴포넌트에 어떻게 분산되는가를 보여주는 분산 시스템 모델
    - 단일 컴퓨터 상에서 구현될 수 있음
  - 서비스를 다른 컴포넌트에 제공하는 서버들의 집합
  - 서버에 의해 제공되는 서비스를 요청하는 클라이언트들의 집합
  - 클라이언트가 서비스에 접근할 수 있게 해주는 네트워크

- Client-Server 아키텍처의 장단점
  - 장점
    - 분산 아키텍처, 많은 분산 프로세서를가지는 네트워크 시스템을 효과적으로 이용할 수 있따. 새로운 서버를 추가하여 시스템의 나머지와 통합하거나 시스템의 다른 부분에 영향을 주지않고 서버를 투명하게 업그레이드하는 것이 용이하다.
  - 단점
    - 새로운 서버의 통합을 위해 기본의 클라이언트와 서버에 대한 변경이 요구될 수 있다. 서버 간에 공유하는 데이터 모델이 존재하지 않아 서브시스템들은 상이한 방식으로 자신들의 데이터를 구성할 수도 있다. 이것은 특정한 데이터 모델이 각 서버별로 설정되어 성능을 최적화할 수도 있다는 것은 의미한다. 물론 만일 XML 기반의 데이터 표현이 이용되면, 하나의 스키마를 다른 스키마로 변환하는것은 비교적 쉬울 수 있다. 그러나 XML은 데이터를 표현하는 비효율적인 방식이므로, 만일 XML이 이용되는 성능문제가 야기될 수 있다.

- 파이프 필터 아키텍처
  - 입력을 처리하여 출력을 생성하는 기능적 변환
  - UNIX 셸에서 파이프 필터 Pipe and Filter모델로 부름
  - 이 방법의 변형은 매우 일반적. 변환이 순차적이면 데이터 처리 시스템에서 광범위하게 이용되는 일괄처리 모델
  - 대화형 시스템에는 적합하지 않음

- 파이프 필터 아키텍처 장단점
  - 장점
    - 변환의 재사용을 지원한다
    - 많은 사람들이 자신들의 작업을 입력과 출력 처리 관점에서 생각한다는 점에서 직관적이다
    - 새로운 변환을 첨가하여 시스템을 진화시키는 것이 쉽사
    - 병행 시스템이나 순차 시스템으로 구현하는 것이 간단한다
  - 단점
    - 모든 변환에 적용될 수 있는 공통적인 데이터 이동 양식이 필요하다
    - 대화식 시스템은 처리될 데이터의 스트림이 필요하기 때문에 파이프라인 모델을 사용하여 작성하기 어렵다

- APP 아키텍처
  - App 시스템은 비즈니스 혹은 조직의 요구를 만족하기 위해 개발됨
  - 비즈니스에서 사용되는 APp 시스템은 공통 부분을 가짐
  - 일반 App 아키텍처는 특정 요구사항을 만족하기 위해 설정되고 변환되는 SW 시스템 유형에 관한 아키텍처

- APP 아키텍처의 이용
  - 아키텍처 설계 프로세스의 출발점
  - 설계 체크리스트
  - 개발 팀의 업무를 조직하느 방법
  - 재사용할 컴포넌트를 평가하는 수단
  - App 유형에 관해 대화하는 용어

- App 유형
  - 데이터 처리 App
  - 트랜잭션 처리 App
  - 이벤트 처리 시스템
  - 언어 처리 시스템

- APp 유형 예
  - 광범위하게 이용되는 두 가지 유형
  - 트랜잭션 처리 시스템
    - 전자상거래 E Commerce 시스템
    - 예약 시스템
  - 언어 처리 시스템
    - 컴파일러
    - 인터프리터

- 트랜잭션 처리 시스템
  - DB에 있는 정보에 대한 사용자 요청이라 DB 갱신을 위한 요청을 처리
  - 사용자 관점
    - 목표를 만족시키기 위한 작업들의 일관된 순서
    - 런던발 파리행 비행편의 시간 검색
  - 일반적으로 사용자가 서비스 요청을 비동기적으로 하는 대화식 시스템

- 정보 시스템 아키텍처
  - 정보 시스템은 계층 아키텍처로 구성될 수 있는 일반 아키텍처를 가짐
  - 일반적으로 DB 트랜잭션을 포함하는 시스템과 상호작용하는 트랜잭션 기반 시스템
  - 계층
    - 사용자 인터페이스
    - 사용자 통신
    - 정보 검색
    - 시스템DB

- 웹 기반 정보 시스템
  - 정보 및 자원 관리 시스템은 현재 대개 웹 기반 시스템으로 사용자인터페이스가 웹 브라우저를사용하여궇ㄴ
  - 예를 들어 전자상거래 시스템은 상품이나 서비스에 대한 전자 주문을 받은 후 고객에게 인도하도록 주선하는 인터넷 기발의 자원 관리 시스템
  - 전자상거래 시스템에서 App별 계층은 사용자가 다수의 품목을 별도 트랜잭션에 배치한 다음, 한 번의 트랜잭션으로 모두 결제할 수 있는 '쇼칭 카트'를 지원하는 추가적인 기능을 포함

- 서버의 구현
  - 이 시스템들은 종종 다단 클라이언트 서버 아키텍처로 구현
    - 웹 서버는 모든 사용자 상호작용을 책임지고, 사용자 인터페이스는 웹 브라우저를 이용하여 구현
    - App 서버는 정보저장과 검색 요청뿐만 아니라 App에 특화된 처리를 구현하는 책임
    - DB 서버는 정보를 DB로 들어가고 나오게 하고 트랜잭션 관리를 다룸

- 언어 처리 시스템
  - 자연어나 인공 언러를 입력으로 받아 해당언어의 다른 표현을 생성
  - 인터프리터를포함할 수 있음
  - 문제를 해결하기 위한 알고지름이나 시스템 데이터를 기수랗는 가장 쉬운 방법으로 사용됨

- 컴파일러 구성요소
  - 어휘 분석기
  - 심벌 테이블
  - 구문 분석기
  - 구문 트리
  - 의미 분석기
  - 코드 생성기

- 모듈 분할의 평가 기준
  - 어떤 모듈이 한 가지 목적을 위한 기능만을 제공하고 있고, 다른 모듈과의 상호작용이 적은 경우, 해당 모듈은 "@기능적 독집성이 높다". 기능적 독집성이 높은 모듈들로 구성된 SW는 각 모듈들의 기능이 명확하게 분리되어 있고 인터페이스도 분명하게 되어 있으므로 개발이 용이하다. 또한 기능적 독집성이 높은 모듈은 설계의 변경과 프로그램의 수정에 의한 부작용이나 파급효과가 국소화되므로 테스트와 유지보수가 수월하다.

- 캡슐화 Encapsulation
  - 서로 관련성이 많은 데이터들과 이와 관련된 함수들을 한 묶음으로 처리하는 것으로서, 캡슐화된 모듈의 세부 내용이 외부에 은폐되어 변경이 발생해도 오류의 파급효과를 최소화시키는 것이다. 캡슐을 구성하는 내부의 입자들의 구체적인 내용은 몰라도 캡슐 자체의 이름과 기능으로 사용하는 예를 따라서 캡슐로 둘러싼다는 의미에서 캡슐화라고 부른다

- 정보 은닉 Information Hiding
  - 각 모듈들은 다른 모듈에게 인터페이스를 통해 서비스를 제공한다. 인터페이스는 모듈의 외부 명세이며, 해당 모듈의 서비스를 이용하기 위해 알고 있어야 하는 정보이다. David L. Parnas가 제안한 "@정보 은닉" 의 개겸은 인터페이스와 구현을 명확하게 분리하여 모듈의 구현에 대한 상세한 설계 정보는 다른 모듈로부터 은폐되어 참조할 수 없도록 해야 한다는 것이다.
  - 캡슐화는 정보 은식을 통해 실현되었으며, 모듈의 프로시져와 모듈 내부의 데이터에 대한 조작에 관한 제약 조건을 규정한 것이다. 모듈 내부에 정의된 변수와 하위 모듈은 외부로부터 은폐되어 직접 액세스할 수 없다. 다른 모듈로부터 액세스하려면 인터페이스로서 정의된 프로시져와 함수를 통해야 한다.
  - 장점
    - 모듈의 구현 내용을 살펴보지 않아도 모듈의 인터페이스를 이해하고 있으면 모듈을 이용할 수 있다.
    - 모듈의 구현을 변경하더라도 인터페이스를 변경하지 않는다면, 해당 모듈을 호출하고 있는 모듈은 아무런 영향을 받지않고 그대로 사용할 수 있다. 이것은 프로그램의 변경이 수월하게 되며 요구사항을 향상시킬 수 있다.

TODO : 4월 24일 시험, 19일 쉬는?  

---

@0412  

- 응집도와 결합도
  - 정보 은닉을위해서는 모듈의 응집도를 높게 하고, 결합도는 낮게 하는 것이 좋다/ SW 설계의 관점에서도 이러한 원칙을 준수하는 것이 바람직하다

- 응집도 Cohesion
  - 한 ㅗ듈 내부에 있는 구성 요소들 사이의 기능적 관련성을 평가하는 준이다. 한 모듈 내부의 구성 요소 사이의 기능저깅ㄴ 관련 정도 및 몯류 내부의 응집도를최대화하는 방향을 설계하는 것이 바람직하다.

@ 시험? (순서?)  

- 결합도 Coupling

- 내용 결합도 Content coupling
  - 어떤 모듈이 인터페이스를 통하지 않도 다른 모듈이 관리하는 데이터 또는 제어 구조를 직접 이용하여 데이터를 직접 참조, 변경하는 경우의 결합도. 다른 모듈의 내부로 제어가 직접 전달되는 경우.

- 공통 결합도 Common Coupling
- 외부 결합도 External Coupling
- 제어 결합도 COntrol Coupling
- 스탬프 결합도 Stamp Coupling
- 데이터 결합도 Data Coupling

