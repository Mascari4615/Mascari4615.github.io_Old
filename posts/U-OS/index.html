<!DOCTYPE html><html lang="ko-KR" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="⛏️ OS, 운영 체제 과목" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="시스템SW 응용SW 작성/운용에 도움을 줄 수 있는, 사용자에게 편리성 제공, 시스템(컴퓨터)에 종속적인 경우가 많음(하드웨어나 다른 시스템 소프트웨어와 접속)(윈도우즈의 경우 창 단위 그래픽), 편집기/IDE, 어셈블리, 컴파일러, 운영체제 등 응용SW 사용자 개인(회사) 각각의 문제 해결을 위해" /><meta property="og:description" content="시스템SW 응용SW 작성/운용에 도움을 줄 수 있는, 사용자에게 편리성 제공, 시스템(컴퓨터)에 종속적인 경우가 많음(하드웨어나 다른 시스템 소프트웨어와 접속)(윈도우즈의 경우 창 단위 그래픽), 편집기/IDE, 어셈블리, 컴파일러, 운영체제 등 응용SW 사용자 개인(회사) 각각의 문제 해결을 위해" /><link rel="canonical" href="https://mascari4615.github.io/posts/U-OS/" /><meta property="og:url" content="https://mascari4615.github.io/posts/U-OS/" /><meta property="og:site_name" content="카모뜨린 아지트" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-09T14:53:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="⛏️ OS, 운영 체제 과목" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"시스템SW 응용SW 작성/운용에 도움을 줄 수 있는, 사용자에게 편리성 제공, 시스템(컴퓨터)에 종속적인 경우가 많음(하드웨어나 다른 시스템 소프트웨어와 접속)(윈도우즈의 경우 창 단위 그래픽), 편집기/IDE, 어셈블리, 컴파일러, 운영체제 등 응용SW 사용자 개인(회사) 각각의 문제 해결을 위해","url":"https://mascari4615.github.io/posts/U-OS/","@type":"BlogPosting","headline":"⛏️ OS, 운영 체제 과목","dateModified":"2023-05-01T15:34:00+09:00","datePublished":"2023-03-09T14:53:00+09:00","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://mascari4615.github.io/assets/img/ProfileImage.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mascari4615.github.io/posts/U-OS/"},"@context":"https://schema.org"}</script><meta name="twitter:card" content="summary"><meta name="twitter:title" content="카모뜨린 아지트}"><meta name="twitter:description" content="기록을 빙자한 일방적 독백"><meta name="twitter:image" content="https://mascari4615.github.io/assets/img/ProfileImage.png"><meta name="twitter:domain" content="카모뜨린 아지트"><title>⛏️ OS, 운영 체제 과목 | 카모뜨린 아지트</title><meta property="og:type" content="website"><meta property="og:title" content="카모뜨린 아지트포기하면 거기서 깁업"><meta property="og:description" content="기록을 빙자한 일방적 독백"><meta property="og:image" content="https://mascari4615.github.io/assets/img/ProfileImage.png"><meta property="og:url" content="https://mascari4615.github.io/"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="카모뜨린 아지트"><meta name="application-name" content="카모뜨린 아지트"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/Mascari4615/Mascari4615.github.io@main/assets/img/ProfileImage.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">카모뜨린 아지트</a></div><div class="site-subtitle font-italic">포기하면 거기서 깁업</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Mascari4615" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>⛏️ OS, 운영 체제 과목</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>⛏️ OS, 운영 체제 과목</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Mar 9, 2023, 2:53 PM +0900" >Mar 9<i class="unloaded">2023-03-09T14:53:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, May 1, 2023, 3:34 PM +0900" >May 1<i class="unloaded">2023-05-01T15:34:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="16740 words">93 min read</span></div></div><div class="post-content"><ul><li>시스템SW<ul><li>응용SW 작성/운용에 도움을 줄 수 있는, 사용자에게 편리성 제공, 시스템(컴퓨터)에 종속적인 경우가 많음(하드웨어나 다른 시스템 소프트웨어와 접속)(윈도우즈의 경우 창 단위 그래픽), 편집기/IDE, 어셈블리, 컴파일러, 운영체제 등</ul><li>응용SW<ul><li>사용자 개인(회사) 각각의 문제 해결을 위해</ul><li>SW vs Program<ul><li>SW는 좀 더 총체적인<li>Program은 좀 더 구체적인</ul><li>운영체제 Operating System<ul><li>컴터를 운영하기 위한 수법과 절차를 모은 SW 체계<li>컴퓨터를 조정 운전하는 SW</ul><li>필요성<ul><li>컴퓨터의 기본적인 처리 과정 고찰<ul><li>IPO Input-Process-Output<li>만약 마우스,키보드,모니터,프린터 등 기본적인 입출력 방법을 운영체제가 제공하지 않는다면<li>키마 VS 콘솔</ul></ul><li>주요 목적 기능<ul><li>편리성 추구<ul><li>사용자와 하드웨어 사이의 중계/기교 역할 담당<ul><li>#인터페이스 역할</ul><li>사용자들이 컴퓨터를 편리하게 사용할 수 있도록 도움을 줌 (사용자 화면)</ul><li>효율성 추구<ul><li>컴퓨터에 설치된 자원들을 효율적으로 사용할 수 있도록 관리하는 자원 관리 역할<ul><li>#작업관리자 열어보면 수백개의 프로그램 프로세스가 실행 중<li>#CPU와 메모리를 어떻게 관리 분배</ul><li>값비싼 컴퓨터의 처리량을 향상시킴으로써 투자 효율 증대 (시스템측면)</ul><li>보안성 추구<ul><li>컴퓨터의 내부 자원HW와 사용자 정보DATA를 보호하는 역할 담당<li>컴퓨터와 사용자를 보호함으로써 지속적 운용 유지(사용자 &amp; 컴퓨터 동시 만족)</ul></ul><li>실체 및 활동<ul><li>하나의 거대한 프로그램<ul><li>사용자에게 서비스(프로그램 적재-실행(입력/계산/출력)-프로그램 제거)를 제공하기 위한 목적으로 메모리에 상주<li>부트 과정을 거쳐 메모리에 설치됨</ul><li>운영체제 접촉<ul><li>사용자들은 시스템 콜 System Call 이라 부르는 서비스 요청 접속 창구를 통해 서비스를 요청하고 결과를 되돌려 받음 (Operating System Interface)<li>시스템 콜은 함수 (라이브러리) 형태로 제공되고, 사용자는 프로그램에서 호출하여 사용<li>#printf, mkdir -&gt; 프로그램이 모니터에 띄우는 게/디렉토리를 만드는 게 아니라, 이를 운영체제에 요청/부탁하고 = 시스템 콜 System Call, 운영체제가 모니터에 띄움/디렉토리를 만듬 -&gt; 다시 호출된 곳으로 복귀<li>#이 외에도 눈에 띄지 않는 운영체제 처리 들이 많음<li>#atoi는 그냥 함수, 근데 printf은 운영체제로, 생긴 것 똑같은 데 처리 과정은 다를 수 있다<li>#Win32API - C, MFC - CPP, 시스템 프로그래머</ul></ul><li>(시스템) 명령어<li>#에 대한 이해<li>#명령어는 결국 프로그램이다 = 운영체제에게 부탁하는 프로그램이다<ul><li>자주 사용되는 시스템콜을 매번 프로그램을 작성하여 서비스를 받아야 한다면 불편<ul><li>예) 디렉토리 생성삭제, 파일 생성삭제</ul><li>위와 같이 자주 사용되는 시스템 콜을 위해 미리 작성되어 있는 프로그램(#실행파일)을 시스템 명령어라 함<li>유닉스/리눅스의 mkdir, rmdir, rm, vi<li>윈도우 도스창의 del, ren, mkdir, rmdir</ul><li>단일 프로그래밍 일괄처리 시스템, Single-stream(줄기가 하나) Batch(바구니, 뭉탱이 한 번에) Processing Systems<ul><li>오직 하나의 프로그램만을 적재하여 실행<ul><li>#공장처럼 하나 처리 후 다름<li>#HDD가 없었기에 펀치카드 다발을 통해 프로그램 자체를 올림<li>#펀치카드 한 장 = 한 문장</ul><li>처리 중인 프로그램이 입출력 서비스를 요청했다면?<ul><li>#다른 일을 처리하지 못하고 계속해서 대기해야 함 =&gt; CPU 효율, Utilization 이용률, Through-put 단위 시간 당 처리량</ul></ul></ul><p>펀치카드 다발 (프로그램)<br /> |<br /> 카드 리더기<br /> |<br /> Main Memory<br /> {<br /> User Program<br /> –<br /> Operating System<br /> }</p><ul><li>다중 프로그래밍 일괄처리 시스템 Multiprogramming Batch Processing Systems<ul><li>메모리를 조각하여, 여러 개의 프로그램을 적재하여 실행<ul><li>#멀티 스트림, 근데 대신 멀티 프로그래밍이라는 용어를 쓴다</ul><li>처리 중이던 하나의 프로그램이 입출력 서비스를 요청했다면?<ul><li>#기본적으로는 처리 끝나거나, 입출력을 시작할 때까지 하나의 프로그램 처리</ul><li>자기 프로그램이 언제 끝날지 예측 불가<ul><li>다른 프로그램이 더 느리다면 그만큼 더 느리게</ul></ul></ul><p>펀치카드 다발 (프로그램)<br /> | | |<br /> 카드 리더기<br /> | | |<br /> Main Memory<br /> {<br /> User Program 2<br /> User Program 1<br /> User Program 0<br /> –<br /> Operating System<br /> }</p><hr /><ul><li>시분할 시스템 Time-Sharing Systems<ul><li>여러 개의 프로그램을 적재하여 실행하되<ul><li>짧은 시간 동안의 주기로 모든 프로그램을 골고루 조금씩 처리<li>한 번에 주어지는 최대 처리 시간을 타임 퀀텀 Time Quantom 혹은 타임 슬라이스 Time Slice</ul><li>다중 사용자들의 대화적 처리 Interactive Processing 환경에 적합</ul><li>병렬 처리 Parallel Processing System<ul><li>다중처리기 시스템 Multi Processor System<ul><li>처리기 CPU 를 여러 개 장착한 시스템<li>#왜 CPU가 아니라 Processor<ul><li>#Processor - CPU FPU GPU 일반화<li>#여기선 CPU를 의미</ul><li>처리기 수 만큼의 프로그램들이 병렬로 처리될 수 있음<li>처리기 일부가 고장나더라도 나머지 처리기들로 기능유지 가능<ul><li>결함 허용 컴퓨터 Fault Tolerant Computer<li>성능 Throughput 과 신뢰성 Reliability 향상<ul><li>#성능 - CPU를 여러 개 장착하는 주된 이유</ul></ul></ul><li>병렬 처리 Parallel Processing 와 병행 처리 Concurrent Processing<ul><li>병렬 처리는 어떤 시각을 기준에서 여러 개의 프로그램을 처리<li>병행 처리는 어떤 시각을 기준에서 오직 한 개의 프로그램을 처리하나, 번갈아 처리함으로써 전체적(거시적)으로 여러 개의 프로그램을 처리하는 효과를 얻음</ul><li>넓은 의미에서 분산 Distributed 처리 시스템의 일종<ul><li>일반적으로 여러 독립된 시스템을 네트워크로 연결<li>시스템 하나에 처리하는 놈을 여러 개 두는 : 간결화 시스템 : 버스로 연결, Tightly-Coupled<li>시스템을 독립시켜놓고 네트워크로 연결하여 분단 처리 : 약결합 시스템 Loosely Coupled</ul></ul><li>병렬 처리<ul><li>대칭형과 비대칭형 다중 처리기 시스템<ul><li>대칭형 다중 처리기 시스템 SMP Symmetric Multi-Processor System<ul><li>처리기들의 역할 범위가 동등, 즉 마스터-슬레이브 개념 없음<li>어느 처리기나 사용자 영역과 시스템 영역 실행 가능<ul><li>운영체제에 부담<li>동시에 시스템 영역을 사용하면 경쟁 상태 발생 가능</ul><li>처리기 하나가 고장나도 작동</ul><li>비대칭형 다중 처리기 시스템 ANP Asymmetric<ul><li>마스터 처리기와 슬레이브 처리기 지정<li>시스템 영역은 마스터 처리기만 실행 가능<li>마스터 처리기가 고장나면 시스템 전체 스톱<li>운영체제 부담, 구현 난이도 감소<li>마스터 고장나면 대책이 없다</ul></ul></ul><li>처리기들 간 버스 연결 방식 (강결합 시스템)<ul><li>단일 공유 버스 Single Shared Bus<ul><li>시스템 전체적으로 하나의 버스를 두고 처리기들이 경쟁하여 사용<ul><li>배타적으로, 하나가 버스를 쓰고 있다면 (데이터를 주고 받고 있다면), 다른 하나가 버스를 사용할 수 없다 (데이터가 깨지니까)</ul><li>처리기를 너무 많이 탑재하면 성능이 오히려 저하<ul><li>CPU를 여러 개 꽂아도, 대기 시간이 존재하기에 성능 향상이 점점 줄어든다</ul><li>멀티 코어 처리기는 처리기들을 하나의 칩으로 통합하여 버스 경쟁, 캐시 정책, 전력 소모 등을 최적화</ul><li>다중 버스 Multiple Bus<ul><li>버스를 여러 개 두고 버스 경쟁률을 완화<li>메모리를 버스 개수 만큼 나눈다<li>은행 창구처럼, 톨 게이트처럼, 하나의 버스가 사용중이면 다른 버스로 메모리에 접근</ul><li>크로스 바 스위치 버스 Crossbar Switch Bus<ul><li>메모리를 여러 개의 모듈 (뱅크)로 분리<li>모든 처리기와 메모리 모듈 사이에 독립적인 버스 경로 가능<li>버스 경쟁으로 인한 성능 저하 최소화<li>같은 버스 수로 다중 버스의 효과를 내면서<ul><li>같은 메모리 뱅크를 사용하지 않는 한<li>대기 시간이 있기는 있음</ul></ul><li>계층적 버스 Hierarchical Bus<ul><li>처리기별로 로 접근컬 메모리, 로컬 디바이스, 로컬 버스를 두고, 대부분로컬 버스로 처리<li>시스템 메모리 접근이 필요한 경우에만 브릿지 컴포넌트를 통해 시스템버스를 사용<li>글로벌 메모리에 있는 변수 접근 시 대기 시간<li>소프트웨어 적으로도 (컴파일러) 여러 기능 필요<ul><li>시스템 메모리로의 주소 바인딩</ul></ul><li>다중 포트 메모리 Multi Port Memory<ul><li>메모리에 접근 포트를 여러 개 두고 각각 독립적으로 경로 가능, 접근 가능<li>각 처리기 별로로 독립된 버스를 분리된 메모리 포트에 연결하여 각각의 병렬 접근을 허용<li>보통 듀얼 포트<li>비디오 RAM (VRAM)이 대표적 사례<ul><li>CPU 각 픽셀의 색 설정<li>GPU 각 픽셀을 모니터에 출력<li>메모리 버스를 가지고 경쟁, 하나가 느리면 병목 현상, 끊어보인다던지<li>그래서 메모리도 크고, 다중 포트</ul></ul></ul><li>#메모리는 여러 종류<li><p>#메인 메모리, 비디오 메모리 등</p><li>분산 처리 (약결합) 시스템<ul><li>여러 개의 독립된 시스템을 네트워크로 연결<li>주어진 일을 분담하여 병렬 처리<li>다중 처리기 시스템도 넓은 의미에서 분산처리 시스템 -&gt; 강결합 시스ㅡ템<li>보통은 약결합 시스템 혹은 클러스터라고 함</ul><li>분산 처리 시스템의 목적<ul><li>처리량 향상, 자원 활용도 향상, 시스템 신뢰도 향상, 점진적 시스템 확장</ul><li>분산 처리 시스템의 제공 기능<ul><li>위치 투명성(분리 된 것이 아니라 우리, 하나로 보이게), 고장 투명성(고장나도 모르고), 접근 투명성(차이가 있어서는 안된다), 중복 및 이동 투명성(중복이어도, 시스템 A에서 B로 옮겨지더라도 사용자가 모르고 쓸 수 있게)</ul><li>분산 처리 시스템의 연결 방식<ul><li>하이퍼큐브 Hyper Cube<ul><li>하이퍼 큐브 연결방식이 대표적<li>8 노드 (시스템)인 경우 각 노드는 3개의 인접 노드를 가짐<li>16노드인 경우 각 노드는 4개의 인접 노드를 가짐</ul><li>완전 연결 Fully Connected<ul><li>초기 설치 비용이 큼<li>사이트 확장 비용이 큼<li>사이트 간 통신 속도가 빠름<li>선로 고장에 따른 신뢰도가 높음</ul><li>성형 Star<ul><li>초기 설치 비용 적음<li>가운데 중계 시스템의 부하 과대<li>중계 시스템의 고장에 따른 신뢰도 저하<li>사이트 추가 비용이 적음</ul><li>링형 Ring<ul><li>완전 연결과 성형의 절충<li>초기 설치와 사이트 확장 비용이 비교적 저렴<li>두 개 이상의 사이트 고장은 네트워크 양분</ul></ul><li>NOS</ul><hr /><ul><li>실시간 시스템 RealTime Systems<ul><li>프로그램의 처리 마감 시한을 보장하느 시스템 (실시간 처리 환경)<ul><li>어떤 사건 Event을 기다리는 프로그램에게, 사건 발생 시각부터 처리 완료 시까지의 최대 소요시간 한계를 보장<ul><li>-&gt; 사건이 발생했는데도 불구하고 해당 프로그램의 실행이 오래도록 지연된다면?</ul></ul><li>경성 실시간 시스템 Hard Real-Time Systems<ul><li>프로그램의 처리 마감 시한을 원래의 개념대로 엄격하게 보장</ul><li>연성 실시간 시스템 Soft Real-Time Systems<ul><li>프로그램의 처리 마감 시한을 원래의 개념대로 엄격하게 보장하지는 못하지만, 해당 프로그램의 처리 지연을 최소화 시킬 수 있음.<li>범용 운영체제인 유닉스, 리눅스, 윈도우 등에서 실시간성 프로그램을 분류하여 관리</ul></ul></ul><hr /><ul><li>컴퓨터 시스템 주요 구성 요소<ul><li>중앙처리장치 CPU Central Processing Unit<li>주기억장치 Main Memory<ul><li>왜 ‘주’ 기억장치냐, CPU가 직접 참조</ul><li>주변 장치 Peripheral Device</ul><li>processor (프로세서)<ul><li>처리기, 일반적으로 중앙처리장치 (CPU) = 명령어를 해석하는 컴퓨터의 한 부분<li><h2 id="그래픽처리장치-gpu-도-컴퓨터의-일부이지만-단지-프로세서-라는-용어만-사용하였을-때-그래픽-처리-장치를-뜻하는-경우는-아직-많지-않음">그래픽처리장치 (GPU) 도 컴퓨터의 일부이지만 단지 ‘프로세서’ 라는 용어만 사용하였을 때 그래픽 처리 장치를 뜻하는 경우는 아직 많지 않음</h2></ul><li>MainBoard, MotherBoard, SystemBoard<ul><li>다 똑같은 용어, 우리나라는 보통 메인보드라 칭하고, 해외에서는 마더보드라 칭하는 경우가 많음</ul><li>@여치<li>버스 Bus<ul><li>CPU(CPU Pin) - Bus(전선, PCB 기판에 붙어있는 얇은 박막) - Memory or 주변 장치<li>엄밀히 따져 딸랑 선만 놓고 버스라고 하진 않지만.<li>데이터 버스만 가지고 신호를 주고 받을 순 없고, 어드레스 버스도 같이 따라다닌다</ul><li>시스템 버스 System Bus<ul><li>어드레스 버스 Address Bus<ul><li>메모리나 입출력 장치에 접근할 때 접근 장소를 식별하기 위한 주소를 전달<li>메모리 크기에 따라 8 16 24 32 64 비트(라인) 등의 크기를 가짐</ul><li>데이터 버스 Data Bus (R/W)<ul><li>메모리나 입출력 장치에서 데이터를 보내거나 읽어올 데이터를 전달<li>데이터 전송 대역폭에 따라 8 16 32 64 비트(라인)등의 크기를 가짐</ul><li>제어 버스 Control Bus (R/W하는 명령/신호 같은)<ul><li>메모리나 입출력 장치 등에 읽기/쓰기 등의 기능을 제어하기 위한 신호 전달<li>신호의 종류에 1/2/3 비트 (라인) 등의 크기를 가짐</ul></ul><li>RAM Random Access Memory<ul><li>임의의 주소에 접근</ul><li>I.E. 8라인 = 2의 8승 = 256B<li>I.E. 16라인 = 2의 16승 = 64KB<li>I.E. 32라인 = 2의 32승 = 4GB<li><p>2의 10승 = 1024 = 1K</p><li>주기억장치 Main Memory<ul><li>비트 Bit 와 바이트 Byte<ul><li>비트 0/1을 기록하는 메모리의 최소 구성 소자<li>바이트 : 8비트로 구성되면 256가지의 서로 다른 정보 저장 가능</ul><li>바이트 별 주소 지정<ul><li>대부분의 컴퓨터는바이트 단위로 주소를 부여</ul><li>바이트 단위 저장<ul><li>읽거나 쓰기는 반드시 바이트 단위로 이루어짐</ul><li>1/2/4/8 바이트 동시 접근 (읽기/쓰기)<ul><li>기계 명령어 Machine Instruction 에 따라 동시 접근하는 바이트 수가 다름</ul><li>메모리 얼라이먼트 Memory Alignment<ul><li>2 4 8 등의 바이트 동시 접근 시 목표시작 주소를,<li>2 4 8의 배수가 되도록 요구하는 기계 CPU 가 있음<li>#1 바이트는 어디서든 되는</ul></ul><li>기계 명령어 Machine Instruction<ul><li>CPU가 처리하는 명령어 단위<ul><li>고급 언어로부터 번역되어 실행 시 메모리에 적재<li>CPU에 의해 인출되어 처리됨</ul><li>연산코드 Operation Code 와 피연산자 Operand<ul><li>연산 코드는 피연산자에 적영할 덧셈, 뺄셈 등의 연산을 의미하는 코드<li>피연산자는 연산에 사용될 값을 의미<li>피연산자로 주기억장치 주소, 상수 ,CPU 레지스터 번호 등이 가능<li>= 위와 같이 다양한 형태의 피연산자를 어드레싱 모드 ADdressing mode라 함<li>피연산자 부분의 크기는 주기억장치의 크기에 영향을 받음<li>#전형적인 기계 명령어 포맷 연산코드 4비트+피연산자 12비트<li>#피연산자 최대 크기에 맞춰서</ul></ul><li>주변 장치 Peripheral Device<ul><li>@여치<li>I/O<ul><li>CPU 입장에서의 입출력<li>사람의 뜻 (조이스틱, 마우스, 키보드 등)을 CPU에, CPU의 뜻 (산술연산 결과, 디스크에 저장된 이쁜 누나 사진 등의 데이터)을 여러분에게 전달하기 위해서(일반적으로 모니터를 통해서)는 반드시 입출력이 필요한 것이다.<li>CPU 입장에서 봤을 때 메모리에 쓰고 읽어오는 것 자체도 I/O지만, 통상 I/O라고 주변 장치들과의 입출력</ul></ul></ul><hr /><h3 id="cpu-명령-사이클-기계-사이클">(CPU) 명령 사이클 (기계 사이클)</h3><p><a href="https://gamedevlog.tistory.com/71">참고</a></p><p>Instruction : 명령, (사전 = 지침)</p><ul><li>Fetch (=bring) 인출<ul><li>CPU가 명령을 수행하기 위해 그 명령어를 레지스터에서 꺼내 오는 것<li>위 말고도 그냥 일반적으로 가져온다는 뜻으로 많이 쓰이기도 하는 듯</ul><li>(CPU) 명령 사이클 Instruction Cycle (기계 사이클 Machine Cycle)<ul><li>CPU의 일과<ul><li>Memory(#주기억장치)로부터 끊임없이 기계 명령어를 주소 번호대로 (차례로) 인출, 해당 명령어가 요구하는 동작을 수행/처리<li>점프를 의미하는 기계 명령어를 만나면 명령어 인출 위치를 변경</ul><li>인출 사이클 Fetch Cycle<ul><li>이번 차례 주소(PC가 가르키는 곳)의 주 기억장치에서 명령어를 읽어 옴<li>인출이 완료되면, PC는 다음 차례의 명ㄴ령어 주소로 업데이트됨</ul><li>해독 사이클 Decoding Cycle<ul><li>연산 코드를 분석하여 어떤 연산인지를 식별함</ul><li>피연산자 사이클 Operand Cycle<ul><li>피연산자 인출이 필요한 경우 지정된 곳에서 피연산자를 읽어옴</ul><li>실행 사이클 Execution Cycle<ul><li>누산기와 피연산자 사이에 연산을 적용하여 명령어를 실행</ul><li>#더 세부적으로 나눌 수도 있고, 각 단계를 더 나눌 수도 있음 (마이너 사이클 or Micro Operation != 메이저 사이클)<li>#톱니바퀴형 파이? 클럭 (CPU 파형)?</ul><li>@여치<li>클럭 CLOCK<ul><li>CPU와 같은 전자회로는 내부적으로 동기(Sync.)가 맞아야한다.<li>회로는 이전의 데이터값에 영향을 받아 작동하므로 이전상태를 [기억]하고 있어야하며 이전 상태와 현재 상태를 가르는 기준으로, 클럭이라 부르는 사각파 전기신호를 사용<li>파형의 한 주기가 한 클럭, 한 주기가 바뀔때마다 새로운 상태 (개념적으로, 이전 상태와 현재 상태가 같을 수 있음)<li>명령어는 한 클럭(한 주기)만에 완료되는 것도 있지만, 아닌것도 많다.<ul><li>회로구성이 이전 상태 (이전 주기)를 필요로 하는 명령<li>메모리 칩 등 속도가 느린 장치를 억세스할때 속도를 맞추기 위해 대기</ul><li>I.E. 2.4GHz 펜티엄 4, 2.4GHz = 클럭 주파수, 초당 24억번 클럭 주기</ul><li>레지스터 Register<ul><li>레지스터 Register란?<ul><li>@여치 : CPU 내의 Memory, CPU의 각 상태 저장, 데이터 이동/연산의 기본 = 프로그래머가 짠 코드는 레지스터를 제어하는 코드<li>메모리와 달리 불규칙적, 소량<li>단순한 값의 저장 기능 외에, 저장 값에 따라 하드웨어 등의 상태에 영향을 미침<li>레지스터는 CPU 내 번호, 주기억장치 주소의 일부 영역, 입출력 포트 번호 등에 의해 접근됨</ul><li>레지스터의 유형<ul><li>CPU 레지스터<ul><li>CPU 내에서 위치하여 CPU 제어, 연산 (누산기) = A Register, 값의 임시 저장 용도 = S Register 로 사용<li><div class="table-wrapper"><table><tbody><tr><td>#A, PC, MBR, MPN<td>S, T</table></div></ul><li>특수 기능 레지스터 SFR Special Function Register<ul><li>컴퓨터 전반에 걸친 상태를 설정하거나 현재 상태 표시</ul><li>입출력 레지스터<ul><li>입출력 장치와 연결되어 입력이나 출력할 때 데이터 전달 통로 역할</ul></ul></ul><li>@여치<li><p>인텔계 x86 cpu는 메모리-&gt;메모리 전송도 가능하지만 그 외 상당수 CPU는 데이터 이동에서도 레지스터를 거쳐야만 하지만</p><li>주소 지정 모드 Addressing Mode<ul><li>주소 즉시 Address Immediate 주소 지정 모드<ul><li>주소 모드<ul><li>피연산자에 나타난 값을 주소로 해석함 (직접 간접, 절대 상대 주소 해당)</ul><li>즉시 모드<ul><li>피연산자에 나타난 값은 상수로 해석함</ul></ul><li>직접 간접 Direct Indirect 주소 지정 모드<ul><li>직접 주소<ul><li>기계 명령어의 피연산자 부분이 주기억장치 접근 주소로 사용되는 경우<li>#주소 -&gt; 값 가져옴</ul><li>간접 주소<ul><li>피연산자 부분이 가르키는 곳에 저장된 기억장치 같이 2차(최종) 주소로 사용되는 경우<li>#주소 -&gt; 주소 -&gt; 값 가져옴 Like 포인터</ul></ul><li>절대 상대 Absolute Relative 주소 지정 모드<ul><li>절대 주소<ul><li>피연산자에 나타난 주소가 그대로 주기억장치 접근 주소로 사용되는 경우<li>#주소 -&gt; 값 가져옴</ul><li>상대 주소<ul><li>피연산자에 나타난 주소에 제 3의 기준 값을 더한 값이 주기억장치 접근 주소로 사용되는 경우<li>#주소 + 기준 값 -&gt; 값 가져옴</ul></ul></ul><li>OP Coder 연산 코드, Operand 피연산자<li>I.E. Add_절대/상대_직접/간접, 상수</ul><hr /><p><a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8_%ED%95%B8%EB%93%A4%EB%9F%AC">참고 0</a><br /> <a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0">참고 1</a></p><ul><li>인터럽트 Interrupt (가로채기, 처리 중간에 방해/중단되고 다른 일을 잠시 처리, 큰 틀에서 봤을 때 처리하는 일은 변함 없음)<ul><li>#CPU에서 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에게 알려 처리할 수 있도록 하는 것<li>CPU에 전달되는 사전 신호 Event Signal<li>사건 신호에는 여러 가지가 있으며, 주로 각각의 전용 회선으로 전달됨 (Source I.E. 키보드 마우스 등)<ul><li>Vectored Interrupt</ul><li>전용 회선이 없는 경우, 어떤 인터럽트가 발생했는지를 탐색해야 함<ul><li>Interrupt Polling(Polling Interrupt)</ul></ul><li>!= <a href="https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">Polling (폴링)</a><ul><li>폴링은 하나의 장치 혹은 프로그램이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치 혹은 프로그램의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 소우신 등의 자료처리를 하는 방식<li>인터럽트는 대상을 주기적으로 감시하여 상황이 발생하면 해당처리 루틴을 실행해 처리하는 폴링과는 달리, 상대가 CPU에게 일을 처리해 달라고 요청하는 수단</ul><li><p>ISR, Interrupt Service Routine Or Interrupt Handler</p><li>인터럽트 우선 순위 Interrupt PRiority<ul><li>여러 개의 인터럽트가 동시에 발생한 경우 대응 처리 순서를 결정함<li>기 발생한 인터럽트에 대한 대응 처리 도중, 다른 인터럽트가 발생했을 때, 그 인터럽트를 보류 시킬 것인지 아니면 지금 즉시 처리할 것인지를 결정함<ul><li>새로 발생한 인터럽트의 우선 순위가 더 높으면 진행 중이던 대응 처리를 잠시 유보하고 새로운 인터럽트 처리를 먼저 처리한 후 재개함</ul></ul><li>인터럽트 사이클 Interrupt Cycle<ul><li>CPU가 인터렙트 발생 여부를 체크(조사)하는 시기를 말함<li>4단계의 명령/기계 사이클을 마치고 인터럽트 발생 여부를 조사함<ul><li>즉, 하나의 기계 명령어에 대한 처리를 마칠 때마다 조사함<li>결국, 명령/기계 사이클은 인터럽트 사이클을 포함하여 총 5단계로 이루어져 있음</ul></ul><li>인터럽트 유형<ul><li>디바이스 인터럽트 Device Interrupt<ul><li>입출력 장치 등 CPU 외부 주변 기기에서 발생하는 인터럽트<ul><li>하드웨어 인터럽트 HW Interrupt 라고도 함</ul><li>오류 인터럽트 Error Interrupt<ul><li>CPU가 기계 명령어를 처리하는 도중에 발생하는 인터럽트<li>잘못된 기계 명령어를 만나거나 0으로 나누는 등의 연산 불가 상황에서 발생<ul><li>예상하지 않는 오류 발생이란 뜻에서 예외 Exception라고 함</ul></ul><li>소프트웨어 인터럽트 SW Interrupt<ul><li>인터럽트를 발생시키는 기계 명령어, 즉 프로그램에 의해 발생된 인터럽트<li>인터럽트 대응 처리를 테스트하거나, 시스템 콜을 위해 사용자 프로그램에서 운영체제로 진입하기 위해 사용<ul><li>프로그램의 흐름을 인위적으로 특별한 부분으로 빠져들게 하므로 트랩 Trap 이라고도 함</ul></ul></ul></ul><li>이중 모드 Dual Mode Operation<ul><li>CPU가 사용자 영역과 시스템 영역을 드나드는 것</ul><li>CPU의 실행모드<ul><li>시스템 모드 System Mode<ul><li>CPU가 운영체제 부분을 실행할 때 설정되는 모드<ul><li>특권 모드 Privileged Mode 또는 수퍼바이저 모드라고도 함</ul></ul><li>사용자 모드<ul><li>CPU가 사용자 프로그램을 실행할 때 설정되는 모드<ul><li>단순히 프로그램 모드라고도 함</ul></ul></ul><li>특권 명령어 Privileged Instruction<ul><li>시스템 모드에서만 실행 가능한 기계 명령어<li>사용자모드에서 실행될 경우 예외 발생<li>입출력 명령어 등 시스템 보호 및 유지를 위해 필요</ul><li>모드간 이동<ul><li>시스템 모드에서 시작(부팅과정)<li>시스템 모드 -&gt; 사용자 모드<ul><li>운영체제가 사용자 모드로 변경하고 사용자 프로그램으로 점프</ul><li>사용자 모드 -&gt; 시스템 모드<ul><li>시간 초과 등의 인터럽트에 의해 운영체제 내 ISR 로 점프하면서 설정</ul></ul><li>입출력 장치 IO Device<ul><li>입력 Input<ul><li>CPU, DMA 등 처리기가 주변 장치의 데이터 레지스터 Data Register로부터 데이터 값을 읽어 주기억장치로 복사하는 작업<li>데이터 레지스터로부터 값을 읽을 때에는 상태 레지스터 Status Register의 데이터 준비 상태를 확인해야 함<ul><li>준비되지 않은 상태에서 읽을 경우 엉터리 값을 읽게 됨</ul></ul><li>출력 Output<ul><li>입력과 반대로 주기억장치으 데이터 값을 읽어 주변장치의 데이터 레지스터로 복사하는 작업<li>데이터 레지스터에 값을 쓰기할 때에는, 상태 레지스터에서 이전 데이터의 출력이 완료되었는지 확인해야 함<ul><li>이전 데이터의 출력 완료 전 또 다른 데이터를 쓰기하면 출력 데이터의 정확성이 보장되지 않음</ul></ul></ul><li>입출력 장치 구조<ul><li>입출력 장치 제어기 IO Device COntroller 입출력장치인터페이스<ul><li>상태 레지스터 Status Register<ul><li>데이터가 입력되었는가 혹은 데이터 출력이 완료되었는 가 등 장치의 상태를 표시하는 곳</ul><li>명령 레지스터 Command Register<ul><li>입력 혹은 출력 하라는 등의 명령을 보내는/쓰는 곳<li>입력 명령에 따라 입력 =&gt; 동기적 입력 (디스크 등)<li>입력 명령없이 수시로 입력 =&gt; 비동기적 입력 (키보드 등)<li>출력은 언제나 동기화</ul><li>데이터 레지스터 Data Register<ul><li>입력된 데이터나 출력될 데이터를 임시 보관하고 있는 곳</ul><li>입출력 장치 구동기 IO Device Driver<ul><li>장치 제어기 인터페이스를 이용하여 입출력을 처리하는 소프트웨어</ul></ul></ul><li>입출력 장치의 식별<ul><li>메모리 대응 입출력 Memory Mapped IO<ul><li>입출력 장치의 레지스터들의 위치를 주기억장치의 주소영역 일부에 대응<li>주기억장치 (변수, 주소)에서 읽고 쓰기하는 동일한 방법으로 입출력이 이루어짐<li>즉, 메모리 접근 명령어와 동일한 기계 명령어 (load, save 등)를 사용하여 입출력을 진행함<ul><li>개발자 입장에서 편리하나, 메모리 공간의 일부는 사용할 수 없음</ul></ul></ul><li>입력 예<ul><li>load r1, 10<ul><li>메모리 10번지에 대응된 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)</ul><li>save r1, 1000<ul><li>입력된 데이터를 메모리 1000번지에 저장</ul></ul><li>출력 예<ul><li>load r1, 2000<ul><li>메모리 2000번지의 데이터를 CPU의 r1 레지스터로 적재</ul><li>saver1, 20<ul><li>적재된 데이터를 메모리 20번지에 대응된 출력 레지스터에 기록 (출력)</ul></ul><li>격리된 입출력 Isolated IO<ul><li>주기억 장치의 주소 영여과 별개로 입출력 장치 주소 영역 (포트, Port)이 따로 있음<li>즉, 메모리 10번지와 입출력 포트 10의 숫자는 동일하지만 지시하는 위치는 전혀 다름<li>따라서, 메모리 접근 기계어 외에 입출력 포트 접근을 위한 전용 기계 명령어 (in, out 등)가 필요함<li>= 메모리 공간을 모두 사용할 수 있으나, 시스템 설계가 다소 복잡해짐</ul><li>입력 예<ul><li>in r1, 10<ul><li>입력 포트 10번지의 입력 레지스터에서 CPU의 r1 레지스터로 읽음 (입력)</ul><li>save r1, 1000<ul><li>입력된 데이터를 메모리 1000번지에 저장</ul></ul><li>출력 예<ul><li>load r1, 2000<ul><li>메모리 2000번지의 데이터를 CPU의 r1레지스터로 적재</ul><li>out r1, 20<ul><li>적재된 데이터를 메모리 20번지인 출력 레지스터에 적재 (출력)</ul></ul><li>컴퓨터 저장장치<ul><li>컴퓨터에 사용되는 저장장치는 가격, 성능, 용량에 따라 계층을 이루고 있다</ul></ul><p>CPU 레지스터 CPU Register<br /> 캐시 Cache { S-RAM Static }<br /> 주기억장치 Main Memory { D-RAM Dynamic Random Access Memory }<br /> 전자디스크 Electronic Disk { SSD }<br /> 자기디스크 Magnetic Disk { HDD }<br /> 광디스크 Optical Disk { CD ROM, DVD }<br /> 자기테이프 Magnetic Tape</p><ul><li>레지스터<ul><li>CPU내에 존재하는 연산 및 임시 저장 용도의 저장 공간</ul><li>캐시<ul><li>CPU와 주기억장치 사이의 속도차 극복을 위한 소량, 고속, 고가 메모리<li>프로그램의 지역성 특성에 의거 90% 이상의 적중<ul><li>#500번지에 접근한다고 할 때, 또 다시 500번지에 접근할 가능성이 높음<li>#때문에 캐시에 적재하는 것이 비효율적이지 않다</ul></ul><li>전자 디스크<ul><li>플래시 메모리 기술에 기반한 SSD Solid State D</ul><li>Memory (메모리)<ul><li>레지스터(CPU) - 캐시메모리 - 주기억장치 - (캐시메모리) - 보조기억장치<li><p>일반적으로 용량과 속도 반비례, 속도와 용량 대비 가격 비례</p><li>레지스터 데이터 읽기 = 머릿속에 있는 기억 떠올리기<li>주기억장치 데이터 읽기 = 책장에 꽂혀 있는 책에서 특정한 책을 찾아 내용을 읽는 행동<li><p>보조기억장치 데이터 읽기 = 지구를 한 바퀴 돌아서 특정한 내용 찾아오기</p><li>@여치<li>임시 기억 장소, 기억장치 대신에 책상, 즉 작업공.<li>책상이 크면 그만큼 많은 것들을 올려놓고 작업할 수 있으니 빠르고 편하다. 책상이 손바닥만하다면 뭐 하나 하려고 하면 올렸다 내렸다 손은 바쁘게 움직이되 일 전체는 느려질 것이다.<li><p>메모리에 뭔가를 저장하고 다시 꺼내오려면, 주소(Address)가 필요하다. Like 물품 보관소</p><li><a href="https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C_%EC%8A%A4%ED%85%81">메소드 스텁</a></ul><li>register (레지스터)<ul><li>프로세서에 위치한 고속 메모리<li>극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역<li>컴퓨터 구조에 따라 크기와 종류가 다양</ul></ul><p>문제 4-2 명령어<br /> 한 자리씩 오른쪽으로 밀린다, 가장 오른쪽에 있었던 것은 가장 왼쪽으로 간다.</p><ul><li><p>입출력 개관</p><li>입출력 과정<ul><li>응용 프로그램의 입출력 요구 =&gt; 운영체제 =&gt; 입출력 장치 (입출력 하드웨어) 인터페이스<li>디스크, 키보드, 모니터, 인터넷 통신, 블루투스 통신, 시리얼 통신</ul><li>직접 데이터 입출력과 간접 데이터 입출력<ul><li>직접 입출력<ul><li>운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공없이 그대로 전달<li>#RAW Device<li>#Special File (!Regular File)<li>#Major Number, Minor Number</ul><li>간접 입출력 (대부분이)<ul><li>운영체제가 응용 프로그램과 HW 사이에서 데이터를 가공하여 전달<li>#계층적 저장구조를 위해서<li>#파일 시스템<li>#TCP/IP 프로토콜 네트워크 패킷(헤더) 같은 걸 붙이는</ul></ul><li>문자 Character 입출력 장치와 블록 Block 입출력장치<ul><li>문자 입출력 장치<ul><li>바이트 단위의 가변적 크기의 입출력 (키보드, LAN 등)</ul><li>블록 입출력 장치<ul><li>디스크의 512바이트 단위 입출력과 같이 일정한 크기의 블록 단위 입출력<li>#하드디스크는 한 바이트를 수정하려면 그 바이트가 포함된 한 섹터를 수정하고 전체를 덮어씌워야 함</ul></ul></ul><hr /><p>파일 기술자 File Descriptor : 파일의 상세 정보에 대한 지시자</p><ul><li>파일 입출력 절차 (유닉스/리눅스)<ul><li>입출력 시스템 호출 (시스템 콜)<ul><li>Open Read Write Close<li>SW 인터럽트 기법으로 OS에 진입<li>Copy in<ul><li>사용자 영역 =&gt; 운영체제 영역 방향으로 데이터 복사</ul><li>Copy-out<ul><li>사용자 영역 &lt;= 운영체제 향으로</ul></ul></ul><li>fd = open(“path”, …) &lt;= 파일 기술자<li>n = read(fd, buf, size)<li>n = write(fd, buf, size)<li><p>close(fd)</p><li><p>파일 테이블</p><li><p>대기 입 출력 Blocking IO과 비대기 입출력 Non-Blocking IO</p><li>입력 대기 방안<ul><li>n = read(fd, buf, size)<ul><li>1바이트라도 입력될 때 까지 대기 -&gt; Blocking IO<li>size 바이트까지 대기 -&gt; Blocking IO<li>입력이 없으면 대기없이 오류 리턴 -&gt; Non-Blocking IO</ul></ul><li>출력 대기 방안<ul><li>n = write(fd, buf, size)<li>1 바이트라도 출력될 때까지 대기 -&gt; Blocking IO<li>size 바이트까지 대기 -&gt; Blocking IO<li>현재 출력이 불가능하면 대기 없이 오류 리턴 -&gt; Non-Blocking IO</ul><li><p>왜 중요하냐, 인터넷에서 클라가 어떤 포털 사이트에 로그인을 신청하면 이 프로그램은 이제 뭘 받아야해 아이디하고 패스워드를 읽어들어야겠지 그게 이걸로 하는거야 인터넷에서는 read 대신 receive도 가능, 서버 입장에서는 합리적인 시간 내에서 입력을 받아야 하겠지, 근데 클라가 만약에 입력을 안해 그러면 요 방시그올 (Block) 운영체제를 운영하고 있다면, 입력이 없으니까 입력 대기 상태에서 멈춰있겠지, 한 사람이면 문제가 없는데 클라가 많은 사람이 연결해서 입력을 안하고 있다면.., + 접속할때마다 메모리도 할당을 해주는데 그게 안딘다, DOS 고의로 연결을 하고 입력을 안하는것, 그래서 Non-Blocking 방식으로, 어느 일정 시간 동안 입력이 없으면 끊어버림, 그런것과 관련이 있다</p><li>입출력 장치 구동기 (드라이버 드라이버 Device Driver)<ul><li>메모리 대응 입출력, 격리된 입출력<li>동기 입력<ul><li>디스크 등과 같이 데이터가 컴퓨터 내부에 저장되어 있는 경우<li>명령 레지스터에 ‘읽기’ 명령을 명시적으로 설정</ul><li>비동기 입력<ul><li>키보드, LAN 등과 같이 데이터가 컴퓨터 외부에서 언제 얼마만큼의 데이터가 입력될 지 예측할 수 없는 경우<li>상태 레지스터의 ‘준비’ 상태로만 확인하여 입력</ul><li>동기 출력<ul><li>출력은 항상 동기식으로만 이룽짐<li>명령 레지스터에 ‘쓰기’ 명령을 명시적으로 설정</ul></ul><li>프로그램 입출력 (바쁜 대기 입출력 Busy-waiting I/O)<li>입출력 장치를 반복구문으로 지속적으로 체크하여 입출력</ul><hr /><ul><li>인터럽트 기반 입출력 Interrupt-Driven I/O<li>입출력 완료 인터럽트 활용<li>vs Busy-Waiting<ul><li>계속 기다리지 않고, 입력이 왔을 때에만 잠깐잠깐 다른 일<li>CPU 효율 증가</ul><li><p>ISR Interrupt Service Routine</p><li>DMA (Direct Memory access) IO<li><p>입출력 전담 처리기 활용</p><li>입출력은<li>단순히 외부 장치의 3가지 레지스터중 Data 레지스터에 대해<li>레지스터에서 메모리로 데이터 복사 = 입력<li><p>메모리에서 레지스터로 데이터 복사 = 출력</p><li>DMA는 위 내용만 할 수 있는<li>(Address, Count, Command)<li>vs Busy-Waiting<ul><li>CPU를 더 불려먹을 수 있다<li>주기억장치가 주기억장치인 이유는 CPU가 메모리에 접근하기 때문인데,<li>DMA도 CPU처럼 직접 메모리에 접근하여 데이터를 넣거나 빼거나<li>= Direct Memory Access</ul><li>입출력 채널 IO Channel<ul><li>입출력이 지나가는 통로<li>IOP IO Processor 라고 부르기도 함<li>DMA도 채널 중이 하나임<li>실렉터 채널, 멀티플렉서 채널, 블록 멀티플렉서 채널 등의 유형이 있음<li>Selector Channel 한 번에 하나 (속도가 빠름), Multiplexer Channel 병렬 처리 (속도가 느려서), Black Multiplexer Channel</ul></ul><hr /><ul><li>버퍼 Buffer<ul><li>임시 보관 장소<li>~= Cache 좀 복사가 빠른 곳에 두는 임시 보관 장소</ul><li><p>프로세스 및 스레드 관리</p><li>프로세스<ul><li>프로그래밍 언어로 작성된 프로그램이, 목적 코드로 (기계어 코드)로 번역되어 디스크에 저장된 후 운영체제의 도움으로 주기억장치에 적재되어 실행 중인 프로그램<li>한 마디로 메모리에 적재되어 실행 중에 있는 프로그램</ul><li>프로세스 속성<ul><li>고유 번호 PID Process Identification Number<li>메모리 정보<li>상태 Status<li>진행지점 Counter<li>문맥 Context<li>우선순위 Priority<li>자원목록 Process Resource<li>회계정보 Accounting Information<li>기타</ul><li>LDA x<li>ADD y<li>STA z<li><p>-&gt; z = x + y;</p><li>중간이 타임아웃이 되면 그 시점의 스냅샷을 저장하고<li>다시 돌아왔을 때 불러와 실행, 연속성<li><p>저장하는 CPU의 내용 = 문맥 Context</p><li>프로세스 관리 블록 PCB<ul><li>프로세스는 OS의 관리 대상<ul><li>프로세스가 하나의 개체로 등록됨<li>프로세스에 관한 모든 정보가 PCb에 기록되어 관리됨<li>PCB의 총 개수가 곧 관리 가능한 최대 프로세스의 수를 의미함</ul></ul><li>프로세스 관리 (상태 천이)<ul><li>운영제체는 프로세스의 처리과정에서 프로세스의 활동에 따라 해당 프로세스를 적절한 상태로 천이 시킨다<li>@실행 상태가 아닌 모든 프로세스는 해당 상태의 대기열에 관리된다</ul><li>프로세스 상태<ul><li>준비 Ready 상태<li>실행 Running 상태<li>대기 Blocked 상태<li>보류 Suspended 상태<li>대기-보류 Block-Suspended 상태<li>종료 Terminated 상태 (Dispatch 배급하다)</ul><li>스레드 Thread (실)<ul><li>프로그램이 실행되는 흐름 줄기<li>보통 프로세스는 하나의 실행 줄기 즉, 하나의 스레드를 가짐 (단일 스레드 프로세스)<li>I.E. C 프로그램의 main() 함수에서부터 시작하는 실행줄기</ul><li>다중 스레드 프로세스 Multi Thread Process<ul><li>다중 스레드 프로세스 개념<ul><li>프로세스는 하나이지만, 여러 개의 실행 줄기(스레드)를 가짐<li>OS는 스레드 별로 독립적인 상태 천이를 관리함<li>즉, 스레드 별로 ~</ul></ul></ul><p>~</p><ul><li>CPU가 반드시 여러 개일 필요는 없음<li>CPU가 여러 개일 경우는 스레드들이 병렬처리됨<li><p>CPU가 하나일 경웅는 스레드들이 병행처리됨</p><li><div class="table-wrapper"><table><tbody><tr><td>LDA<td>100</table></div><li><p>주소 100</p><li><div class="table-wrapper"><table><tbody><tr><td>LDA_S<td>100</table></div><li>주소 100 + Stack Pointer<li><p>상대주소기법</p><li><p>스레드 생성 및 제거</p><li>프로세스 생성 및 제거<ul><li>프로세스 생성<ul><li>새로운 프로세스는 이미 실행 중인 다른 프로세스가 OS에 오청함으로써 탄생<li>이들은 부모 프로세스 Parent Process의 자식 프로세스 Child Process 관계가 됨<li>단말기 (키보드) 사용자들은 실행하고자 하는 프로그램의 이름을 쉘 (명령어 해석기)에 전달하여 쉘로 하여금 프로그램 생성을 OS에게 요청하도록 함<li>디스크 프로그래믕 메모리로 적재하여 프로세스를 생성하는 OS부분을 로더 Loader 라함</ul></ul><li>프로세스 제거<ul><li>정상적인 프로세스 제거는 해당 프로세스 스스로가 운영체제에게 요청함으로써 이루어짐</ul></ul><hr /><p>@0406</p><ul><li>프로세스 간 통신 IPC InterProcess Communication<ul><li>일반적인 프로세스들은 완전히 독립되어 다른 프로세서들과 격리되어 정보를 교환할 수 있음<li>거대한 프로그램을 작게 분리한 경우, 이를 프로세스 간의 통신 수단이 요구됨<ul><li>클라이언트 Client -&gt; 서버 모델</ul><li>대표적인 통신 수단을 파이프, 메시지, 큐, 공유 메모리, 세마포, 소켓(인터넷)을 들 수 있음<li>통신 경로는 운영체제에 의해 제공되기 때문에 각각의 통신 수단마다 고유의 셋업 절차를 따라야 함</ul><li>프로세스 통제<ul><li>실행중인 프로세스에 대한 어떤 조치를 취하는일</ul><li>프로세스 통제수단<ul><li>OS가 제공하는 서비스 (씨스템 콜)을 이용<li>유닉스/리눅스의 경우 kill() 시스템 콜</ul><li>프로세스 통제 유형<ul><li>강제 종료 :<ul><li>실행중인 프로그램이 스스로 종료하기 전에 무조건 강제로 종료하도록 한다</ul><li>일시 정지 :<ul><li>완전히 종료하도록 하느 것은 아니고, 임시로 CPU의 할당을 받지 못하여 더 이상의 실행이 이루어지지 않도록 한다</ul><li>실행 제개 :<ul><li>일시 중지 상태에 있는 프로세스가 CPU를 할당 받아서 계쏙 수행할 수 있도록 한다.<li>우선 순위에 따라 다른 프로세스와 공평하게 CPU를 할당받는다</ul><li>약속 처리 :<ul><li>프로그램을 작성할 때 약속했던 처리 부분들을 실시간으로 지시한다</ul><li>우선 순위 변경 :<ul><li>실행중인 프로그램의 우선순위를 올리거나 내린다.<li>일반 사용자는 내리기만 가능하고,관리자는 양쪽 모두 가능하다.</ul></ul><li><p>프로세서 CPU 관리</p><li>프로세서 Processor란?<ul><li>주기억장치에 저장된 프로그램 (기계 명령어)를 읽어가면서 처리하는 CPU<li>기타 DMA와 같이 제한된 기능만을 수행하는 프로세서도 있음<li>처리기로 부르는 경우도 있음</ul><li>프로세서 관리<ul><li>다수의 사용자 프로그램이 있을 때 (멀티프로그래밍), 어느 프로세스를 선택하여 CPU를 보낼 것인가의 문제<li>CPU 스케쥴링 이라 부르기도함<li>OS 설계자와 추구하는 바에 따라 ~?</ul><li>단계별 처리 스케줄링<ul><li>장기 스케줄링 Long-Term Scheduling<ul><li>어느 프로그램을 먼저 적재할 것인가 하는 수준의 스케줄링<li>잡 스케줄링이라고도 함</ul><li>중기 스케줄링 Medium-Term Scheduling<ul><li>메모리에 적재된 프로그램들 중, 상당기간 동안 처리를 보류하여 자원을 확보하는 차원의 스케줄링<li>대상이 된 프로세스들은 잠시 디스크로 이동하여 기다림 (스와핑)</ul><li>단기 스케줄링 Short-Term Scheduling<ul><li>실행 준비가 된 프로세스들 중, 어느 프로세스에게 CPU를 보낼 것인가 하는 수준의 스케줄링<li>보통 CPU 스케줄링이라 함은 이 수준을 말함 (이후 통일)</ul></ul></ul><hr /><p>@0411</p><ul><li><p>CPU 스케줄링 전략의 목표 및 기준</p><li>사용자 관점에서의 기준 (평가 기준)<ul><li>응답 시간 Response Time<ul><li>사용자 입력에 대하여 출력이 이루어질 때까지 소요되는 시간<li>동일한 조건에서 CPU 스케줄링 방법에 따라 달라질 것임</ul><li>반환시간 Turnaround Time<ul><li>프로그램이 제출(혹은 적재)된 후 최종 결과물을 얻을 때까지의 소요시간<li>총 처리시간이라고도 함</ul><li>대기 시간 Waiting Time<ul><li>CPU가 주어질 때까지 기다리는 시간들의 합<li>CPU는 자주 조금씩 주어짐</ul><li>지표 분석<ul><li>사용자들은 세 가지 지표가 모두 짧아지기를 희망</ul></ul><li>시스템 관점에서의 기준<ul><li>CPU 이용률 CPU Utilization<ul><li>CPU가 순수하게 사용자 프로그램을 실행하는데 소요한 시간의 비율<li>쉬는 시간이나 시스템 자체의 내부 처리를 위해 보낸 시간이 많으면 좋지 않음<li>@ 문맥 교체 등</ul><li>처리량 Throughput<ul><li>전체적으로 단위 시간당 처리하는 프로그램의 수</ul><li>지표 분석<ul><li>시스템 (컴퓨터 운영자) 입장에서는 두 지표 모두 높이기를 희망</ul></ul><li>@ ~ 사용자 관점과 시스템 과점의 두 입장이 상충됨<li><p>둘 다 잡을 수 없음 = 하나는 조금 희생해야 한다</p><li>기타<ul><li>가용성 Availability<ul><li>전체 시간 (서비스, 고장, 유지보수, 점검 등) 대비 서비스 시간의 비율 (신뢰성, 가동율)<li>특정 자원에 대하여 즉시 접근할 수 있는 정도 (즉시 접근 가능 빈도 비율)</ul></ul><li><p>CPU 스케줄링이 이루어지는 시기</p><li>프로세스가 입출력을 요구할 때<ul><li>진행 중이던프로세스가 입출력을 요구하면, OS는 입출력 진행중인 동안 마냥 기다릴 수 없으므로 다른 프로세스를 선택해서 CPU를 보내야한다.&lt;- 비선점 CPU 스케줄링</ul><li>프로세스가 종료를 요구할 때<ul><li>프로그램의 진행 절차상 모든 처리가 끝나 종료를 선언하면, OS는 다른 프로세스를 선택하여 CPU를 보내야 한다 &lt;- 비선점 CPU 스케줄링</ul><li>높은 우선 순위의 프로세스가 나타났을 때<ul><li>높은 우선순위의 프로세스가 입출력을 마치고 준비상태로 전환되면, OS는 현재 실행중인 프로세스를 보류하고, 더 높은 우선 순위의 프로세스에게 CPU를 보낼 수 있다. &lt;- 선점 CPU 스케줄링</ul><li>실행시간이 초과되었을 때<ul><li>현재 실행 중인 프로세스에게 허용된 최대 실행 시간이 초과하면, CPU는 다른 프로세스 ~여 CPU를 보낼 수 있다. &lt;- 선점 CPU 스케줄링</ul><li>선입 선처리 FCFS First-Come First-Served 스케줄링<ul><li>개념<ul><li>준비 대기열 Ready Queue 에 도착한 순서대로 처리<li>입출력이나 종료 시까지 계속 실행 &lt;- 비선점형<li>분석</ul></ul><li>최단 작업 우선 SJF Shortest Job First 스케줄링<ul><li>개념<ul><li>현재 준비 대기열 Ready Queue에 도착한 프로세스들 중, CPU 버스트 CPU Burst가 짧은 것을 선택하여 실행<li>SPN Shortest Process Next 라고도 함<li>즉, 입출력이나 종료 시까지 계속 실행 &lt;- 비선점형</ul><li>분석<ul><li>기아 상태 현상<li>CPU 버스트는 어떻게 계산?<ul><li>예측 하는 방법론이 있다 (수업에서 다루지는 않음)</ul></ul></ul></ul><hr /><p>@0413</p><ul><li>최단 잔여 시간 우선 SRTF Shortest Remaining Time First 스케줄링<ul><li>개념<ul><li>실행 중 새로운 프로세스가 도착하면, 현 프로세스의 남은 시간과 새 프로세스의 CPU 버스트 시간을 비교하여 새 프로세스가 더 짧으면 교체 &lt;- 선점형</ul><li>분석<ul><li>평균 대기 시간과 평균 응답 시간을 더욱 개선 -&gt; CPU 이용률 저하 현상 발생 억제<li>반면 기아 상태 발생 가능성 더 높음</ul></ul><li>최고 응답률 우선 HRRF Highest Response Ratio First 스케줄링<ul><li>HRN Highest Response Ratio Next<li>응답률<ul><li>CPU 버스트 대비 대기열에서 기다린 정도의 검증 (CPU 버스트가 크면 그만큼 많이 기다려도 무바앟다는 취지)<li>응답률 = (준비큐 대기시간 +CPU버스트 시간) / (CPU 버스트시간) = 1 + 준비큐시간 / CPU 버스트 시간)<li>선점 혹은 비선점 운영 가능</ul><li>개념<ul><li>SJF나 SRTF의 기아 Starvation 현상을 해결</ul></ul><li>라운드 로빈 RR Round Robin 스케줄링<ul><li>개념<ul><li>모든 프로세스에게 동일한 최대 실행 허용 시간 (타임 퀀텀 혹은 타임 슬라이스)를 부여하고, 그 시간만큼씩 공평하게 조금씩 CPU를 보냄 &lt;- 선점형</ul><li>분석<ul><li>타임 퀀텀에 따른 문맥 교환 Context Switching)<li>부담 및 평균대기 시간</ul></ul><li>다단계 큐 MQ Multi-Level Queue<ul><li>개념<ul><li>모든 프로세스에게 획일적인 스케줄링 전략을 적용하지 않고, 프로세스들을 특성별로 그룹화하여 각각 독립된 정책을 사용</ul><li>예 -프로세스를 중요도 등에 따라 크게 그룹화하여 별도의 큐 관리<ul><li>계산 위주의 프로세스들은 타임 퀀텀을 길게 주고, 우선 순위는 낮게 부여<li>입출력 위추 프로세서들은 반대로</ul><li>분석<ul><li>더욱 정교한 전략을 적용하기 위해 동일 준비 큐 프로세스들 간에는 다른 스케줄링 전략이 적용</ul></ul><li>다단계 피드백 큐 MFQ Multi-level Feedback Queue</ul><hr /><p>@0418</p><ul><li>병행처리 Concurrent Processing와 경쟁상황Race Condition<ul><li>병행처리<ul><li>하나의 CPU가 여러 개의 프로세스를 조금씩 번갈아 처리<li>거시적 관점에서 여러 개의 프로세스를 한꺼번에 처리하는 효과<li>어느 순간에 보면 오직 하나의 프로세스만이 처리되지만, 공유 변수를 접근한다면 경쟁상황이 발생할 수 ‘있음’ = 무조건 발생이 아님 (병렬처리보다는 빈도가 낮음, 섞일 수도 있음)</ul></ul><li>병렬처리 Parallel Processing와 경쟁상황<ul><li>병렬처리<ul><li>다수의 CPU가 여러 개의 프로세스를 한꺼번에 처리<li>어느 순간에 보면 여러 개의 프로세스들이 처리<li>공유변수를 접근한다면 경쟁상황이 더욱 심하게 발생할 수 ‘있음’ = 무조건 발생이 아님 (근데 병행처리보다는 빈도가 높음, 섞일 수도 있음)</ul></ul><li>임계영역 Critical Section<ul><li>경쟁상황이 발생되어 처리의 오류를 일으킬 수 있는 부분</ul><li>상호배제<ul><li>임계 영역에서는 오직 하나의 프로세스만이 진입할 수 이ㅆ도록함<li>상호배제는 잠금 Looking 장치와 채제 UnLock 장치로 실형</ul><li>프로그램 동기화 Process Synchronization<ul><li>임계 영역을 설정하고 그리고 그 어 구분에다가 상호배제 잘치를 잘 설치</ul><li>상호배제 절차 (잠금과 해제 장치)의 조건<ul><li>계속 진행<ul><li>임계 영역에 진입한 프로세스가 없을 때는 원하는 프로세스가 곧바로 진입할 수 있어야함</ul><li>항호 배제<ul><li>임계 영역에 진입한 프로세스가 존재하면 다른 프로세스들의 진입을 불허되어야 함</ul><li>대기 한정<ul><li>임계 영역 진입을 원하는 프로세스들은 랜덤하고 공평하게 진입할 수 있는 기회가 주어져야 함</ul></ul><li>상호배제의 구현 방법<ul><li>순전히 SW로만 구현하는 방법<li>HW의 지원을 받아 구현하는 방법</ul></ul><hr /><p>@0420</p><ul><li><p>미완성 SW 상호배제 시도들</p><li>공통 깃발 체크 방법<ul><li>whilie(flag == 1); flag = 1;<li>병렬 처리일때 거의 동시에 진입하면 경쟁상황 발생 가능<li>병행 처리일때 한 프로세스가 대기 이후 flag = 1; 처리 직전, 주도권이 다른 프로세스로 넘어가고, 해당 프로세스에서도 flag = 0; 처리 직전, 주도권이 다른 프로세스에 넘어가면 경쟁상황 발생 가능 (공유 변수가 덮어씌워지는)</ul><li>자기 깃발 표시 방법<ul><li>while(flag[1] == 1); flag[0] = 1;<li>공통 깃발 체크 방법과 유사<li>flag[0] = 1; while(flag[1] == 1);</ul><li>차례지키기 방법<ul><li>동시에는 못들어감<li>근데 자기 차례가 아니면 공회전 하는 경우 +&gt; 계속 진행 X</ul></ul><hr /><p>@0504</p><ul><li>Spin Lock 스핀 록 (if then else white, TAS SAWP, 빙글빙글 돈다 - CPU를 쓴다)<ul><li>앞에서 제시된 SW 및 HW 상호배제 기법들은 모두 바쁜 대기 기반의 잠금장치들임 &lt;- 스핀록<li>이런 방법들은 때에 따라 CPU 낭비가 심하고 임계 영역에 진입한 프로세스가 비정상적으로 활동하면 파급효과가 큼<li>따라서 보다 편리하고 보편적인 개념의 잠금장치가 필요 &lt;- 세마포</ul><li>세마포 (빙글빙글 돌지 않고 대기)<ul><li>S 열쇠<li>P(S) 열쇠를 가져가는 연산 (열쇠 -= 1)<li>P(S) 연산 시 열쇠가 없으면 (열쇠 == 0) 대기 -&gt; OS가 처리<li>V(S) 열쇠를 돌려놓는 연산 (열쇠 += 1)</ul><li>이진 세마포와 카운팅 세마포<ul><li>이진 세마포 : 주로 상호배재 용으로, 박자 맞추기<ul><li>세마포 변수 S를 0 or 1로 초기화하고 0 or 1 이외의 값을 사용치 않는 경우<li>1로 초기화 시 상호 배재, 0으로 초기화 시 보조동기화용으로 사용됨<ul><li>While(1) P(S) … (V), V(S) P(S), V(S) 이후 기다렸다가 P(S) 하는</ul></ul><li>카운팅 세마포 : 박자 맞추기, 리소스 카운팅<ul><li>기능은 똑같은 데 1 이상의 값을 사용하는<li>S를 Buffer 개수로 생각, 가져갈 때 P(S)<li>왜 S -= 1 일반 연산 안씀 ? -&gt; 이거 자체가 임계 영역</ul></ul><li>생산자-소비자 문제 Producer-Consumer Problem<ul><li>개념<ul><li>한 쪽 프로세스는 데이터를 생산하여 전달하고, 다른 한 쪽 프로세스는 전달 받은 데이터를 처리하여 소모함<li>E Empty, F Full, M Mutual Exclusion (상호배재용 = 열쇠?)<li>I.E. Circular Queue 에 한 쪽은 데이터를 넣고, 한 쪽을 데이터를 꺼냄<li>소비자 (P(F), P(M), F 하나 채움, 0이면 대기, V(M), V(F))<li>생산자 (P(E), P(M), E 하나 채움, 0이면 대기, V(M), V(E))<li>I.E. 박자 맞추기<li>소비자 While P(S) Process(Data)<li>생산자 While GetData() V(S)</ul></ul><li>Dining Philosophers Problem 식사하는 철학자들 문제<ul><li>개념<ul><li>잠금 (세마포)이 해재디기를 영원히 기다리는 상황, 즉, 교착 상태를 살표보는 상징적 문제</ul></ul><li>모니터의 개념<ul><li>프로그래밍 언어 수준에서 제공되는 고수준 상호배재 장치<ul><li>함수(서브루틴, 메소드) 형태로 구분된 임계 영역들의 모임<li>모니터 내에서는 오로지 하나의 프로세스만이 진입 가능<li>모니터는 고유의 식별 이름을 가짐<li>세마포의 잘못된 사용에 따른 오류 가능성을 개선<li>@ 알잘딱으로 한 놈만 들어가도록 감시</ul></ul><li>모니터의 내부(조건) 큐<ul><li>모니텅 진입한 프로세스가 시간이나 자원을 기다리기 위해 잠시 실행을 유보해야 하는 상황<li>해당 프로세스는 모니터 잠금 장치를 해제하고 자신은 내부 큐에서 대기<li>다른 ㄹ프로세스가 모니터에 진입하여 처리르 마치고 나가면서, 필요한 경우 내부 큐에 대기중인 프로세스에게 잠금을 인계 &lt;- 대기 중이던 프로세스가 모니터 내에서 실행을 제개</ul><li>자바 모니터<ul><li>자바는 객체 단위로 모니터를 형성<li>해당 모니터에는 synchronized 메소드들만 포함함</ul></ul><p>@0509</p><ul><li>교착 상태 Deadlocks<ul><li>고장난 좌물쇠 -&gt; 나가지도 못하고 나오지도 못함<li>진퇴양난 -&gt; 영원히 기다리는 상황<li>주요 원인 : 고장이나 기타 이유로 인한 자원의 부족</ul><li>컴퓨터 자원의 유형<ul><li>HW 자원과 SW 자원<li>선점 가능한 자원과 선점 불가능 자원<li>공유 가능 자원과 배타적 사용 자원</ul><li>컴퓨터의 자원 관리 모델<ul><li>요청 -&gt; 사용 -&gt; 반납 (묵시적, 명시적)<ul><li>프로세스들은 OS에게 필요한 자원을 요청<li>지원 요청은 시스템 콜을 사용하여 이루어짐<li>유닉스/리눅스의 대표적인 자원 요청 시스템 콜은 open(), 자원 반납 시스템 콜은 close()</ul></ul><li>교착 상태의 필요조건<ul><li>자원의 배타적 사용 Mutual Exclusion<li>자원의 점유 대기 Hole &amp; Wait<ul><li>자원의 부분 할당 Partial Allocation</ul><li>자원 비선점 No Preemption<li>자원에 대한 환형 대기 Circular Wait<ul><li>자원 할당 그래프 RAH Resource Allocation Graph로 판별 가능</ul></ul><li>교착 상태 대응 방안<ul><li>교착 상태 예방 Prevention<ul><li>교착 상태의 필요조건 중 하나가 성립하지 않는 할당정책 도입</ul><li>교착 상태 회피 Avoidance<ul><li>자원을 할당하면서 교착 상태 발생 가능성이 있으면 추가 할당 보류</ul><li>교착 상태 탐지 및 복구 Detection &amp; Recovery<li>교착 상태 방치 Don’t Care</ul></ul><p>@0511</p><ul><li>교착 상태 예방 Prevention<ul><li>교착 상태의 필요조건 중 하나가 성립하지 않는 할당정책 도입<li>자원의 배타적 사용 조건 제거<ul><li>컴퓨터 자원의 대부분은 배타적으로 사용되어야함, 도입 불가</ul><li>자원의 점유 대기 조건 제거<ul><li>사용할 자원 전체를 한꺼번에 할당할 수 있을 때까지 기다림<li>여러 종류의 자원이 필요한 프로세스의 기아 상태 가능성<li>자원을 미리 확보함으로써 활둉도 저하, 도입 곤란</ul><li>자원의 비선점 조건 제거<ul><li>자원이 부족하면 이지 점유 중인 자원을 강제 회수<li>롤백 Rollback, 등 큰 비용 동반, 도입 곤란</ul><li>자원에 대한 환형 대기 조건 제거<ul><li>모든 자원에 일련 번호를 부여하고, 프로세스에게 자원을 할당할 때는자원의 번호 순서대로만 할당, 환형 대기 조건 발생하지 않음</ul></ul><li>교착 상태 회피 Avoidance<ul><li>자원을 할당하면서 교착 상태 발생 가능성이 있으면 추가 할당 보류<li>Safe 상태와 Unsafe 상태<ul><li>Safe State<ul><li>자원 할당이 이루어지더라도 교착 상태가 결코 일어나지 않는 상태<li>현재 남은 자원이 부족하더라도 점유 중인 프로세스 종료로 자원이 반납되어 모든자원 할당 요구를 만족-하는 시나리오가 존재하면</ul><li>Unsafe State<ul><li>자원 할당이 이루어진 후, 이후의 모든 자원 할당을 만족시킬 시나리오가 존재하지 않는 경우</ul></ul><li>자원 할당 그래프 예약 간선, 안전 상태 판별, 교착 상테 회피<ul><li>자원 할당 그래프의 예약 간선<ul><li>현재요청된 자원을 할당 햇다는 가정 하의 자원 할당 그래프<li>예약 간선이 포함된 자원 할당 그래프로부터 안정 상태 여부 판별<li>안전 상태가 아니면 자원 요청 보류</ul></ul><li>Dijstra의 은행가 알고리즘 Banker’s Algorithm<ul><li>개념<ul><li>자원에 대한 잠재 수요 및 재고 현황으로부터 안전 상태 식별</ul></ul></ul><li>교착 상태 탐지 및 복구 Detection &amp; Recovery (주기적으로, 가끔)<ul><li>자원 할당 그래프로부터 안전 상태 여부 판별<ul><li>점유 대기 현상 (환형 대기, 사이클, Cycle) 이 존재하는지 조사<li>사이클이 존재한다고 하여 반드시 교착 상태는 아님</ul><li>사이클 탐색 알고리즘<li>교착상태 복구<ul><li>교착 상태를 복구 (해제)하기 위해서는 자원 강제 회수가 불가피<ul><li>프로세스 단위의 자원 회수<ul><li>희생 Victim 프로세스를 선정하고, 그 프로세스의 점유 자원 전체를 회수<li>자원이 부족하면 계속해서 희생 프로세스를 선정하여 회수<li>자원을 회수 당한 프로세스는 강제 종료 (Roolback)</ul><li>개별 자원 단위의 회수<ul><li>희생 프로세스가 점유하고 있는 자원 중 일부만 회수<li>자원의 일부를 회수당한 프로세스는 후퇴하여 재실행 Rollback</ul></ul></ul></ul><li>교착 상태 방치 Don’t Care<ul><li>교착 상태 예빵, 회피, 탐지 및 복구는 심각한 부담 (성능 저하)를 동반<ul><li>OS는 교착 상태와 관련하여 어떠한 활동도 하지 않음<li>교착 상태에 관계되어 실행이 중단된 프로세스들은 사용자가 인식하고 처리<li>대부분의 사용 OS에서 채택</ul></ul><li><p>메모리 관리 개념</p><li>메모리 할당 및 회수가 이루어지는 시기<ul><li>디스크의 프로그램이 메모리에 적재되어 생성될 때 &lt;- 첫 할당<li>프로세스가 종료되었을 때, 회수<li>프로세스가 메모리르 추가 요청할 때, 추가 할당<li>프로세스의 실행을 잠시 보류하고 디스크로 옮길때, 회수<li>디스크의 보류되었던 프로세스를 다시 실행 재개할 때, 재할당</ul><li>할당 메모리 위치<ul><li>메모리 할당은 반드시 비어있는 곳에 이루어짐<li>재 할당의 걍우 꼭 동일장소에 이루어져야 할 수도 있고, 다른 빈 공간에 이루어질 수도 있음</ul><li>메모리 관리의 필요성<ul><li>위와 같이 메모리는 할당과 회수가 역동적으로 이루어지므로 어느곳이 비어있는지 어느 프로세스에게 어디에 어느만큼의 메모리가 할당되었는지에 대한 관리가 필요함</ul><li>메모리 관리 전략(방법)의 분류<ul><li>~</ul><li>전체 적재와 일부 적재, 그리고 가상 메모리<ul><li>전체 적재<ul><li>프로세스를 실행하기 위해 프로세스 이미지 (Text,Data,Stack등) 전체를 적재<li>가장 기본적이고 이해가 쉬운ㅇ 전략<li>실행중인 프로세스들 크기의 총합은 컴퓨터 메모리(주기억장치) 용량 초과 불가<ul><li>다중 프로그래밍 정도 Degree of Multiprogramming 가 낮아질 수 밖에 없음</ul></ul><li>일부 적재<ul><li>프로세스 이미지의 필요한 일부만 적재하여 실행<li>복잡하고 기교스런 관리 기법이 요구됨<li>실행 중인 프로세스들 크기의 총합이 메모리 용량을 훨씬 초과할 수 있음<ul><li>가상 메모리 Virtual Memory<li>다중 프로그래밍 정도를 높일 수 있음</ul></ul><li>연속 ~<li>논리 주소와 물리주소 Logical &amp; Physical Address</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EF%B8%8Fmemo/'>⛏️Memo</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=⛏️ OS, 운영 체제 과목 - 카모뜨린 아지트&url=https://mascari4615.github.io/posts/U-OS/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=⛏️ OS, 운영 체제 과목 - 카모뜨린 아지트&u=https://mascari4615.github.io/posts/U-OS/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=⛏️ OS, 운영 체제 과목 - 카모뜨린 아지트&url=https://mascari4615.github.io/posts/U-OS/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li> <a href="/posts/My-Dictionary/">⛏️ 메모</a><li> <a href="/posts/Unity-UI/">🌱 Unity UI 메모</a><li> <a href="/posts/DayStone-230521/">🌱 마작</a><li> <a href="/posts/DayStone-230518/">🌱 감기</a><li> <a href="/posts/DayStone-230515/">🌱 날계란</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unity/">Unity</a> <a class="post-tag" href="/tags/vrc/">VRC</a> <a class="post-tag" href="/tags/programmers/">Programmers</a> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/c/">C</a> <a class="post-tag" href="/tags/cpp/">CPP</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/OnParticleCollision-Not-Work/"><div class="card-body"> <span class="timeago small" >Jan 6<i class="unloaded">2023-01-06T23:46:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>🕯️ OnParticleCollision 이 호출되지 않을 때</h3><div class="text-muted small"><p> 💎 OnParticleCollision 이 호출되지 않을 때 파티클 시스템에서 Collision 이 켜져있는 지확인 Collision 에서 Type 이 World 인지 확인 (기본 Plane) ⭐ Collision 에서 Send Collision Messages 가 켜져있는지 확인 Collision 에서 Collision Qual...</p></div></div></a></div><div class="card"> <a href="/posts/Prefix-K-For-Constants/"><div class="card-body"> <span class="timeago small" >Jan 6<i class="unloaded">2023-01-06T23:46:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>🕯️ 상수 이름에 접두사 k, 헝가리안 표기법</h3><div class="text-muted small"><p> 💎 상수 이름에 접두사 k 참고 요약 : c는 char의 약자로 이미 쓰고 있기 때문에, 수학에서 상수로 쓰이고, 독일어로 상수의 첫 글자인 (konstant), k 를 쓰게 되었다. … 혹은 그저 정말 발음이 유사해서 썼다던지. private const int kVariable = 1; 위처럼 상수 이름 앞에 k를 붙이는 경우...</p></div></div></a></div><div class="card"> <a href="/posts/The-Swap-Trick/"><div class="card-body"> <span class="timeago small" >Jan 7<i class="unloaded">2023-01-07T23:22:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>🕯️ The Swap Trick</h3><div class="text-muted small"><p> 💎 The Swap Trick : 메모리 재할당 참고0 참고1 참고2 참고3 읽기 좋은 코드가 좋은 코드다의 84p 에서 언급된 The Swap Trick. 아래는 책에 나온 예제 코드다. struct Recorder { vector&lt;float&gt; data; ... void Clear() { ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/U-DB/" class="btn btn-outline-primary" prompt="Older"><p>⛏️ DB, DB 설계 과목</p></a> <a href="/posts/U-Cloud-Computing/" class="btn btn-outline-primary" prompt="Newer"><p>⛏️ 클라우드 컴퓨팅 과목</p></a></div><script src="https://utteranc.es/client.js" repo="Mascari4615/blog-comments" issue-term="pathname" theme="dark-blue" crossorigin="anonymous" async></script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href=""></a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/unity/">Unity</a> <a class="post-tag" href="/tags/vrc/">VRC</a> <a class="post-tag" href="/tags/programmers/">Programmers</a> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/c/">C</a> <a class="post-tag" href="/tags/cpp/">CPP</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://Mascari4615.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-QRNK1L0YH7"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-QRNK1L0YH7'); }); </script>
