---
title: "🌱 NormalMap"
date: 1999-01-01. 00:00
categories: 🗿Stone 🌱DayStone
---

시작. 일단. 먼저.  
크게 도움은 안되는. 단순 잡학/정보 공유.  
하지만 꽤 흥미로운. 그래서 준비  

텍스쳐 강의. 노멀맵을 설명해주시는 부분 중에 인상 깊은 부분  
노말맵을 알베도에 넣은 머테리얼을 메시에 적용시키면. 빨간색이 나온다  

이게 알아볼 주제.  
정말 도움은 안되는. 왜냐면 알베도에 노말맵을 넣을 일이 없으니까  
그치만 궁금하죠.  
노말맵에 대해서도 친해져보는, 내부 사정을 좀 알아보는  

결론  
이 노말맵은 빨간색이기 때문이다.  

아 그렇구나..  
하고 끝나면 안되겠죠  

왜 노말맵이 빨간색인지,  
그리고 왜 유니티 에디터는 빨간색 노말맵을 파란색으로 보여주고 있는지  

노말맵의 원리와 압축방식과 대해 알아야 한다.  

노말맵.  

설명해주셨던 것처럼, 굴곡을 만들어주는, 특정 부준을 그림자지게 만들어주는, 그래서 퀄리티가 높아보이게 만들어주는 텍스쳐.  
실제 메쉬 폴리곤 디테일이 없는 부분을 디테일이 있는 것처럼 보이게하는 맵  

일반적으로는,  
로우폴리메시에서 하이폴리메시의 디테일을 살려주는 역할  

https://docs.unity3d.com/kr/2020.3/Manual/StandardShaderMaterialParameterNormalMap.html  
노말맵이 쓰이는 예시를 하나 보겠습니다.  
이렇게 나사나 조금씩 파인 곳 같은 디테일을 메쉬로 만들 수도 있는데,  
그렇게 되면 큰 메쉬에서 미세한 폴리곤을 써야 하고, 미세한 폴리곤이 쓰인다는 것은 폴리곤 수 자체도 늘어난다는 것이고, 최적화 측면에서, 관리 측면  

어떤 방식으로 디테일을 살려주냐  
노말.  

(하이폴리의) 노말 정보를 텍스쳐 이밎 형태로 저장하여 로우폴리에 적용  

하이폴리 -> 폴리곤이 많음 -> 노말이 많음  
로우폴리 -> 폴리곤이 적음 -> 노말이 적음  

R U  
G V  
B Normal  

https://www.reddit.com/r/Unity3D/comments/vcty4f/pink_normals/  
Unity Normal맵 압축에 DXTnm을 사용하고 노멀을 RGBA = (1.0, y, y, x)로 저장  

https://steamdb.info/patchnotes/5003146/
https://docs.unity3d.com/kr/2020.3/Manual/SL-BuiltinIncludes.html  

https://80.lv/articles/overwatch-technical-overview/  
오버워치는 실제로 노란 노말맵을 쓴다  
BC5 같은 압축 방법을 써서, 추후에 언팩(압축해제)할때 블루 채널을 만들어낸다  
이는 성능이 뛰어나고, 적은 아티팩트  

일반 노멀 맵을 얻으려면 알파 채널을 녹색 채널로 이동하고 파란색 채널을 순수한 흰색

https://catlikecoding.com/unity/tutorials/rendering/part-6/

https://docs.unity3d.com/kr/2020.3/Manual/SL-BuiltinIncludes.html
유니티경로/Data/CGIncludes/UnityCG.cginc  

UnpackScaleNormal

```c

inline fixed3 UnpackNormalDXT5nm (fixed4 packednormal)
{
    fixed3 normal;
    normal.xy = packednormal.wy * 2 - 1;
    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
    return normal;
}

// Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
// Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
fixed3 UnpackNormalmapRGorAG(fixed4 packednormal)
{
    // This do the trick
   packednormal.x *= packednormal.w;

    fixed3 normal;
    normal.xy = packednormal.xy * 2 - 1;
    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
    return normal;
}

inline fixed3 UnpackNormal(fixed4 packednormal)
{
#if defined(UNITY_NO_DXT5nm)
    return packednormal.xyz * 2 - 1; //DXY가 아니면 그냥범위만 조정해서  
#else
    return UnpackNormalmapRGorAG(packednormal);
#endif
}

```

https://community.gamedev.tv/t/baking-normal-map-on-orc-horn-turning-out-yellow/182487  
파랑 노말맵에 중간중간 노란 노말맵  
면이 뒤집혀져 있다던지?  

- Normalmap을 쓰기 위해 프로퍼티에 _BumpMap("Normalmap" ,2D) = "bump"{} 를 선언
- Normalmap은 게임용 텍스쳐 포맷인 DXT1, DXT5가 아니라 DXTnm의 포맷
- DXTnm은 일반적인 텍스처 압축으로 인한 Normalmap 품질저하를 막기위한 AG파일 포맷
- 이 텍스쳐를 이용하여 Normalmap을 생성해내려면 함수를 사용해야 함

이 파일 포맷은 일반적인 텍스쳐의 압축에 의한 NormalMap 품질의 저하를 막기 위해 만든 AG 파일 포맷. 이 포맷은 NormalMap의 R과 G의 퀄리티를 최대한 보전하여 A와 G에 넣어 저장함. (B는 가지고 있지 않음) 이렇게 보전된 R과 G는 NormalMap의 X와 Y로 계산되며, Z는 삼각함수를 이용하여 수학적으로 추출됨

그러므로 이 텍스쳐를 이용해서 NormalMap으로 온전하게 생성해내려면 앞에 설명한 공식이 적용되어 있는 함수를 이용하면 간편함.

DXT5nm에서의 노멀 처리.

위는 DXTnm나 BC5의 노멀 텍스쳐의 RGB 색상에 1개의 채널을 더해 RGBA로 바꾸고 소스 R은 G로, 소스G는 A로 변경해 R과 B는 공백으로 둔다.(이렇게 됨으로 아티팩트를 줄일수 있음) 따라서 packednormal.xy는 packednormal.ag와 동일하다.

이는 DXT5  R:5 G:6 B:5 A:8로 변환(RGB16bit를 24bit RGBA로 변환)할때 G와A채널 값이 가장 크기 때문

https://docs.unrealengine.com/5.1/ko/vector-operation-material-expressions-in-unreal-engine/  
https://forum.unity.com/threads/modifying-standard-shader-to-work-with-dxt-normal-textures.774353/  
https://forum.unity.com/threads/runtime-generated-bump-maps-are-not-marked-as-normal-maps.413778/  
5.5보다 새로운 Unity 버전을 사용하는 경우 빨간색과 파란색 채널이 검은 색이 아닌 흰색이어야합니다. 그러나 더 이상 작동하기 위해 노멀 맵을 스위즐링할 필요도 없습니다.  

전체 "노멀 맵" 지정은 게임과 렌더링 시스템에 개념이 없는 순전히 에디터 텍스처 임포터이며, 특별한 방식으로 포맷된 텍스처2D 애셋일 뿐입니다.

경고가 귀찮고 커스텀 셰이더를 사용하는 경우 _BumpMap 또는 _NormalMap라는 텍스처 속성 또는 [Normal] 재질 속성 서랍을 사용하지 마십시오.  

2017.2 ~ 2018.4 사이에  
이전에는 float4(1, y, 1, x)로 표시되었지만 이제는 float4(x,y,?,1)입니다.  

2017.1에 BC5 노멀맵에 대한 지원 추가  
선택적으로 RGBA 1y1x (실제로는 스위즐 DXT5인 "DXTnm" 또는 스위즐 RGBA32인 "선형 Nm 32비트"로 표시됨) 및 RG xy01 팩 노멀(BC5는 항상 0.0B 및 1.0A를 반환하는 5채널 RG 전용 형식임)을 모두 사용할 수 있습니다. 6.2018 및 이전 버전의 경우 실제로 yyyx로 압축되었지만 GA 채널 만 사용되었습니다.

4.5에서는 둘 다 계속 지원됩니다. HDRP의 기본값은 BC5 노멀 맵입니다. LWRP 다른 개정판의 기본 형식에 BC1 및 이전 "DXTnm"을 모두 사용하는 것을 보았지만 현재 기본값을 살펴 않았습니다. 내장 렌더링 경로 인 AFAIK는 여전히 DXTnm을 사용하지만 1y01x 및 xy<>이 모두 지원됩니다.

RGBA(107, 153, 250, 255)는 Unity 2017, 1부터 RGBA(153, 107, 255.153)가 되어야 합니다. 실제로 B 값은 다소 임의적이며 0, 255, G 또는 텍스처에 압축하려는 다른 임의의 데이터가 될 수 있지만 일부 추가 압축 아티팩트가 필요합니다. 그 이유는 지난 게시물에서 볼 수 있듯이 Unity가 R 채널과 A 채널을 함께 곱하여 인코딩 된 X를 얻었 기 때문에 Unity 2017.1 이상은 RG 및 AG 일반 인코딩을 모두 지원합니다.

이 값에 대해 조금 더 다루고 싶었습니다. BC (일명 DXTC) 압축 형식이 작동하는 방식, 빨간색 및 파란색 채널은 각각 5 비트를 사용하고 녹색 채널은 블록 색상 팔레트 당 인코딩에 6 비트를 사용합니다. 즉, 녹색 값이 빨간색 또는 파란색보다 정밀도가 약간 더 높기 때문에 Y가 녹색 채널에 남아 있습니다. Unity는 실제로 "DXTn"을 (1.0, y, y, x)로 저장하지만 G와 B의 정밀도 차이는 셰이더로 샘플링할 때 완벽하게 동일하지 않을 수 있음을 의미합니다. 솔직히 왜 파란색 채널에서 Y를 복제하기로 선택했는지 모르겠지만 그레이 스케일 값으로 저장했기 때문에 3 개 채널 모두 Y를 유지하고 빨간색을 1.0으로 변경하는 것이 기존 코드에 대한 가장 작은 변경 사항이었습니다. 데이터가 RGB 채널에 복제 될 때 일부 인코더가 약간 더 잘 수행 될 수 있지만 형식이 그렇게 더 잘 압축 될 기술적 인 이유는 없습니다.

https://someiyoshino.info/entry/20171205/1512486725

DXTC, DXT5, BCn BC3  
Direct X Texture Compression  
Block Compression  

DXT5 = BC3  

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hram01&logNo=221489477514  
